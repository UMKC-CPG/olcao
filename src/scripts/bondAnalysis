#!/usr/bin/env perl

sub printHelp
{
   print <<ENDHELP;
#PROGRAM:  bondAnalysis
#PURPOSE:  This program will take an atomic structure data file in one of many
#          possible formats and will produce a new file that contains
#          information about the nearest neighbor relationships between atoms.
#          This can typically be considered as a bond analysis, but the data
#          is produced simply based on geometrical considerations, not on any
#          quantum mechanical calculations such as the OLCAO bond order.
#
#The -o option allows the user to designate a different name for the resultant
#   output file rather than the default "bondAnalysis.xx" file.  The "xx" in
#   the output depends on the data requested, for the -bs option, "xx"="bs",
#   and for -ba "xx"="ba" and so on. A special case occurs for the -frag option
#   where the the name specified here serves as an identifier for a set of
#   output files, each with a different suffix.
#The -i option allows the user to designate a different name for the input
#   file rather than the default expected input file of "olcao.skl".  Other
#   options include files such as the "structure.dat" OLCAO input file, the
#   VASP input file "POSCAR".  (At present only the olcao.skl option works.)
#The -s option allows the use of OLCAO bond order results to support the
#   bond analysis. The default file name expected to contain BO data is
#   "S1__S1.dat". This file is made using makeBOND with a group control file
#   containing only the filter, "SYSTEM_NUM". Often, one may add an additional
#   option to the makeBOND command of "-minbo 0.0".
#The -dist option takes one parameter called \$limitDist which is a measure in
#   angstroms of the cutoff distance beyond which atom-atom distances should
#   not be considered.  If this option is *not* given, then the program will
#   assume a default cutoff of 4 angstroms.
#The -bs -ba -bl -boo -dx -st and -co options are all mutually exclusive.  The
#   one given last (relatively) on the command line will be the one that is
#   performed.
#The -bs option will print a file that can be used to produce a ball and stick
#   figure through some third party software.  The format is the lattice
#   parameters given in a,b,c x,y,z format followed by a line with the number
#   of atoms, followed by a line for each atom.  These lines have the element,
#   the species number, the atomic coordinates in either x,y,z direct, a,b,c
#   direct, or a,b,c fractional, and the list of the atom numbers to which
#   each atom bonds.
#The -vtk option will print a file in legacy VTK format that shows a ball and
#   stick model. This file can be easily read in by Paraview.
#The -ba option is a list of the bond angles for each pair of atoms bonded to
#   each atom.  The output is divided into groups, one group for each atom.
#   The first line of a group is the number of bond angles in that group.  The
#   remaining lines are the various bond angles.  Each bond angle line has the
#   form of two triplets and the bond angle in degrees.  The first triplet is
#   the element name and species number of each atom in the triplet with the
#   vertex atom in the middle.  The second triplet contains the atom number in
#   the same order.  Then, the bond angle is given in degrees.
#The -bl option is a list of the bond lengths for each atom that is "bonded"
#   to each other atom.  The output is divided into groups, one group for each
#   atom.  The first line of a group contains the number of bonds in that
#   group and the element name and species number of the atom that is common
#   to all the bonds in that group.  The next lines contain the element name
#   and species number of each atom bonded to the common atom along with their
#   bond lengths and atom number.
#The -boo option will compute the so-called bond orientational order number of
#   each atom in the model.  The output is simply a list of the element name,
#   species number, index number, and BOO number of each atom. The -Ylm_l
#   suboption sets the l order of the Ylm spherical harmonic to use to
#   distinguish the bond orientational order of different atoms. Currently
#   only 0, 1, and 6 are allowed values.
#The -dx option will produce a file that can be used to view the structure in
#   openDX.  The bonds are based simply on the covalent radii of each atom.
#   The atom colors and sizes are pulled from the ElementData.pm module.
#The -st option will compute a set of statistics about each element, species,
#   and atom and will print them.  The statistics include average bond lengths,
#   and the bond length standard deviation, the average bond angle and the bond
#   angle standard deviation.
#The -co option will compute (and print) the coordination for each atom and
#   will also produce and print a summary of the coordinations for each element.
#The -qn option will compute the Q^n distribution for a crystal. By default,
#   the assumption is that the "bridging" atom is oxygen. However, the -b
#   \$bridges parameter can be used to define a different bridging element. The
#   element(s) must be specified as lower case names from the periodic table.
#   If there is more than one name, then enclose in quotes and separate by
#   spaces. Similarly, by default, silicon is assumed to be the coordinated
#   cation but the -i \$ions option can be used to change that. Again, if more
#   than one cation should be considered, then enclose a space separated list
#   in quotes.
#The -3dfull option will produce a single OpenScad model file that can be used
#   to produce data for a 3D printer. This model will contain all atoms and
#   bonds of the complete system unioned together so that the whole model prints
#   as one piece. This option has three suboptions: -a will scale the radius
#   of the atoms where the default is the covalent radius, -b will scale
#   the diameter of the bond sticks where the default is 10% of the covalent
#   radius of the largest radius in the model, -c will scale the overall
#   size of the crystal lattice.  NOTE, bad choices for these values will
#   result in bad looking models. The -r option takes a number that defines
#   the ratio between the bond rod radius and the covalent radius.
#The -3dparts option will produce a collection of OpenScad model files that
#   contain descriptions of the individual parts associated with an atomic
#   scale model. When the parts models are printed on a 3D printer they can be
#   used to assemble a large complex 3D structural model. The three sub-options
#   work the same way for this command as they do for the -3dfull option. The
#   additional -vol option is used to specify the printable volume that the 3D
#   printer has accessible to it. The -r option takes a number that defines
#   the ratio between the bond rod radius and the covalent radius. The -f
#   option affects the font size for labels. The font size is taken as 0.9
#   times the radius of the bond cylinder. This option allows one to change
#   the value of 0.9 to any other value.
#The -bf option allows the user to define a multiplicative factor for the
#   determination of which atoms are bonded.  The default value is 1.  Atoms
#   are considered to be bonded if their interatomic distance is <= (the sum of
#   their covalent radii) * \$bondingFactor.  Be careful that the largest
#   expected bond length does not exceed the limit distance set with -dist.
# The -xyz option will print the atomic positions in x,y,z direct space
#   (cartesian) instead of the default a,b,c direct space coordinates.  This
#   option will affect the interpretation of the coordinates specified in the
#   -box option and it is mutually exclusive with -fract.
# The -fract option will print the atomic positions in a,b,c fractional
#   coordinates instead of the default x,y,z direct space (cartesian).  This
#   option will affect the interpretation of the coordinates specified in the
#   -box option and it is mutually exclusive with -xyz.
# The -box option will use only a limited portion of the system to compute
#   bond length and bond angle statistics.  The min and max values are used to
#   define the inclusive range over each axis within which atoms are to be
#   considered as "inside" the box.  You may optionally use the word "max"
#   instead of a specific number for \$max1,2,3.  This will automatically use
#   the maximum value so you don't have to look it up or worry about rounding
#   issues.  The minimum value of 0 is easy to remember and works for all cells
#   so there is no "min" option.  The \$zone can be either 1 or 2.  If it is 1,
#   then only atoms inside the box are considered.  If it is 2, then only atoms
#   outside the box are considered.  The default behavior if this option is not
#   given is to use abc coordinates and include all atoms inside the entire
#   cell.
# The -hist option will request that instead of printing the computed
#   statistics in a single structured data file with exact numerical values,
#   the output will be in the form of a histogram with spacing \$histDelta.
## The -frag option will produce a set of files that describe the bonds and
##   bond angles of the molecule as a whole AND that describe the bonds and bond
##   angles associated with fragments of the molecule. Fragments are defined
##   according to a chain length. For this particular option, there is a side
##   effect that the \$outFile is interpreted to be an outFileTag that will have
##   various different suffixes applied.
## The -c suboption is used to specify a chain length for fragment creation.
##   The chain length is an integer number that defines the depth of the search
##   search tree that is used to find atoms from some starting H atom. If this
##   option is not given then a default chain length of 3 will be used. (For
##   example, a chain of H-C-B would be included for fragment generation, but
##   H-C-B-B would not.)
# The -help option will print this description and usage information.
#
#USAGE:  bondAnalysis [-o \$outFile] [-i \$inFile] [-s] [-dist \$limitDist]
#                     [-bs | -ba | -bl | -boo [-Ylm_l \$Ylm_l] | -dx | -st
#                     | -co | -qn [-b \$bridges ] [-i \$ions] | -vtk
#                     | -rn \$minRingLen \$maxRingLen ]
#                     |-3dfull  [-a \$aScale -b \$bScale -c \$cScale
#                                -r \$bondRadiusScale]
#                     |-3dparts [-a \$aScale -b \$bScale -c \$cScale -f \$fScale
#                                -r \$bondRadiusScale -vol \$x \$y \$z]]
#                     [-bf \$bondingFactor] [-xyz | -abc | -fract]
#                     [-box \$min1 \$max1 \$min2 \$max2 \$min3 \$max3 \$zone]
#                     [-hist \$histDelta]
##                     [-frag [-c \$chainLength]]
#                     [-help]
#
ENDHELP
   exit(0);
}

###############################################
# Begin program execution #####################
###############################################

# Use necessary modules.
use strict;
use warnings;
use Env;
use sort 'stable';
use Math::Trig;
use lib "$OLCAO_BIN/perl5";
use POSIX qw(ceil floor);
use StructureControl;
use ElementData;

# Declare global variables
# Command line defined options.
my $outFile;
my $inFile;
my $bondOrderFile;
my $bondingFactor; # Multiplicative factor to elemental covalent bond lengths.
my $limitDist; # Cut off distance for consideration of any bonds.
my $operation;
my $coordType; # 1 = directXYZ; 2 = directABC; 3 = fractABC.
my $coordLabel;
my @boxBorders;
my $zone;
my $Ylm_l; # Allowed values are 0, 1, 6.
my $qOrder_ref;
my $aScale; # Atom scale factor for openscad models.
my $bScale; # Bond scale factor for openscad models.
my $cScale; # Cell scale factor for openscad models.
my $fScale; # Font scale for labels in 3dParts.
my $xVol3D; # x dimension for the 3D printer's volume in mm.
my $yVol3D; # y dimension for the 3D printer's volume in mm.
my $zVol3D; # z dimension for the 3D printer's volume in mm.
my $bondRadiusScale;
my $fontSize;
my $histDelta; # Histogram spacing in appropriate units.
my $useOLCAOBO;
my $doHist;
my @bridges; # Name of elements to consider as a bridge for Q^n.
my @ions; # Name of elements to consider as ions for Q^n.
my $minRingLen; # Smallest length ring to seek.
my $maxRingLen; # Largest length ring to seek.
#my $chainLength;
#my $doFrag;

# System defined variables.
my $numAtoms;         # Number of atoms in the system.
my $numAtomsExt;      # Number of atoms in the system included extended cells.
my $numElements;      # Number of unique elements in the system.
my $realLattice_ref;  # Lattice vectors in abc,xyz
my $mag_ref;          # Magnitudes of the a,b,c vectors.
my $coords_ref;       # Coordinates in some form (xyz; abc direct; abc fract)
my $coordsExt_ref;    # Extended cell coordinates in same form as above.
my $elementList_ref;  # List of unique elements in the system.
my $numSpecies_ref;   # Number of species for each element.
my $speciesList_ref;  # Species tag for each species of each element.
my $coordination_ref; # String giving the coordination of each atom.
my $coordinationSummary_ref; # The coordination summary of each element.
my $atomQn_ref;       # The Q^n of each atom.
my $absoluteSysQn_ref; # The absolute number of atoms with Q^n of n.
my $fractionalSysQn_ref; # The fractional number of atoms with Q^n of n.
my $numQnAtoms;       # Number of atoms participating in the Q^n calc.
my $netConnQn;        # The Q^n network connectivity.
my $atomRings_ref;    # List of which rings each atom is a member of.
my $rings_ref;        # List of rings (which atoms belong to each ring).
my $ringCounts_ref;   # A count of the number of rings of each length.
my $bondedList_ref;   # List of bonded central cell atom numbers.
my $bondedExtList_ref; # List of bonded extended cell atom numbers.
my $bondLengthExt_ref; # Bond lengths of each bond.
my $bondAnglesExt_ref; # The actual bond angles.
my $numBonds_ref;      # The number of bonds for each atom.
my $numBondAngles_ref; # The number of bond angles for each atom.
my $atomSpeciesID_ref; # Species ID number of each atom.
my $atomElementID_ref; # Element ID number of each atom.
my $atomElementName_ref; # Element name of each atom.
my $atomCovalRadii_ref;  # Covalent radius each atom.
my $atomColorVTK_ref;  # Color for VTK for each atom (based on CPK chem.)
my $ext2CentralItemMap_ref; # Mapping between extended and central cell.
                            #   Index # is extended cell, stored # is central.
my $central2ExtItemMap_ref; # Mapping between central cell and extended cell.
                            #   Index # is central cell, stored # is the
                            #   extended list # for that central cell atom.

# Computed statistics for each element, species, and atom.
my @avgElemBL;
my @avgElemBA;
my @avgSpecBL;
my @avgSpecBA;
my @avgAtomBL;
my @avgAtomBA;
my @stdElemBL;
my @stdElemBA;
my @stdSpecBL;
my @stdSpecBA;
my @stdAtomBL;
my @stdAtomBA;

# Fragment data.
#my $numUniqueFragments;
#my @fragmentTagList;

# Useful kludges.
my $atomLabel = 0;  # This stupid global variable is a product of laziness.  It
                    #   keeps track of the number of atoms that have been
                    #   labeled so far.


# BEGIN NON-INITIALIZATION EXECUTION


# Initialize the environment.
&initEnv;

# Parse the command line.
&parseCommandLine;

# Apply the bonding factor to the database.
ElementData::applyBondFactor($bondingFactor);

# Read the input file.
StructureControl::readInputFile($inFile,1);

# Obtain a reference to the lattice parameters.
$realLattice_ref = StructureControl::getRealLatticeRef;

# Obtain a reference to the magnitudes of the lattice vectors.
$mag_ref = StructureControl::getMagRef;

# Set the limit for atom interaction.  (Maximum bond limit)
StructureControl::setLimitDist($limitDist);

# Establish the bounding box that constrains which atoms to consider.
&setBoxBorder;

# Create the list of which atoms are bonded to which atoms.
StructureControl::createBondingList;

# Compute the bond angles.  For each atom in the central cell, obtain a list of
#   bond angles between all pairs of bonded atoms.
StructureControl::computeBondAnglesExt;

# Obtain a reference to the list of atoms bonded to each atom.  "Bonded" in
#   this case means that the atoms are within the sum of the covalent radii of
#   each other including the bondFactor effect.  The ID numbers of the atoms
#   are all with respect to atoms inside the central cell.
$bondedList_ref = StructureControl::getBondingListRef;

# Obtain a reference to the list of atoms bonded to each atom.  "Bonded" in
#   this case means that the atoms are within the sum of the covalent radii of
#   each other including the bondFactor effect.  The ID numbers of the atoms
#   may be in reference to atoms outside the central cell.
$bondedExtList_ref = StructureControl::getBondingExtListRef;

# Obtain a reference to the list of bond angles for each central cell atom.
$bondAnglesExt_ref = StructureControl::getBondAngleExtRef;

# Obtain references to the mappings between the extended cell atom numbers and
#   the central cell atom numbers.
$ext2CentralItemMap_ref = StructureControl::getExt2CentralItemMapRef;
$central2ExtItemMap_ref = StructureControl::getCentral2ExtItemMapRef;

# Obtain the meta-data about the atom list.
$numBonds_ref = StructureControl::getNumBondsRef;
$numBondAngles_ref = StructureControl::getNumBondAnglesRef;

# Obtain the number of atoms and elements in the system.
$numAtoms = StructureControl::getNumAtoms;
$numAtomsExt = StructureControl::getNumAtomsExt;
$numElements = StructureControl::getNumElements;

# Obtain a reference to the covalent radii of each atom.
$atomCovalRadii_ref = StructureControl::getCovalRadiiRef;

# Obtain a reference to the color of each atom.
$atomColorVTK_ref = StructureControl::getColorVTKRef;

# Obtain a reference to the atom names.
$atomElementName_ref = StructureControl::getAtomElementNameRef;

# Obtain a reference to the unique element names in the system.
$elementList_ref = StructureControl::getElementListRef;

# Obtain a reference to the number of species for each element.
$numSpecies_ref = StructureControl::getNumSpeciesRef;

# Obtain a reference to the various atomic species tags for each unique element.
$speciesList_ref = StructureControl::getSpeciesListRef;

# Obtain a reference to the species ID number of each atom.
$atomSpeciesID_ref = StructureControl::getAtomSpeciesIDRef;

# Obtain a reference to the element ID number of each atom.
$atomElementID_ref = StructureControl::getAtomElementIDRef;

# Get the atomic positions in (x,y,z), (a,b,c) direct, or (a,b,c) fractional
#   coordinates.
if ($coordType == 1)
{
   $coords_ref = StructureControl::getDirectXYZRef;
   $coordsExt_ref = StructureControl::getDirectXYZExtListRef;
   $coordLabel = "(x,y,z) direct";
}
elsif ($coordType == 2)
{
   $coords_ref = StructureControl::getDirectABCRef;
   $coordLabel = "(a,b,c) direct";
}
else
{
   $coords_ref = StructureControl::getFractABCRef;
   $coordLabel = "(a,b,c) fractional";
}

# Obtain the bond lengths of each bond in the system with reference to atom
#   numbers including those outside the central cell.
$bondLengthExt_ref = StructureControl::getBondLengthExtRef;


if ($operation == 4) # Set up bond orientational order data.
{
   # Set the order of the spherical harmonics to use.
   StructureControl::setYlm_l($Ylm_l);
 
   # Create the list of which atoms are bonded to which atoms.
   StructureControl::createQList;
 
   # Obtain a reference to the qOrder.
   $qOrder_ref = StructureControl::getQOrderRef;
}
elsif ($operation == 6) # Compute statistics about bl's and ba's.
   {&computeStatistics;}
elsif ($operation == 7) # Create the coordination data.
{
   # Create the coordination list and the coordination summary.
   StructureControl::createCoordinationList;
   StructureControl::createCoordinationSummary;

   # Obtain a reference to the coordination of each atom.
   $coordination_ref = StructureControl::getCoordinationRef;

   # Obtain a reference to the coordination summary of each element.
   $coordinationSummary_ref = StructureControl::getCoordinationSummaryRef;
}
elsif ($operation == 12) # Create the Q^n data.
{
   # Create the Q^n lists (atomic, absolute, and fractional). Also compute
   #   the Q^n network connectivity.
   StructureControl::computeQn(\@bridges,\@ions);

   # Obtain a reference to the Q^n of each atom.
   $atomQn_ref = StructureControl::getAtomQnRef;

   # Obtain a reference to the absolute and fractional system Q^n.
   $absoluteSysQn_ref = StructureControl::getAbsoluteSysQnRef;
   $fractionalSysQn_ref = StructureControl::getFractionalSysQnRef;

   # Obtain the number of atoms participating in the Q^n calc.
   $numQnAtoms = StructureControl::getNumQnAtoms;

   # Obtain the Q^n network connectivity.
   $netConnQn = StructureControl::getNetworkConnectivityQn;
}
elsif ($operation == 13) # Create the ring data.
{
   # Create the ring membership lists.
   StructureControl::computeRingDistribution($minRingLen, $maxRingLen);

   # Obtain a reference to the ring membership list of each atom.
   $atomRings_ref = StructureControl::getAtomRingsRef;

   # Obtain a reference to the list of rings.
   $rings_ref = StructureControl::getRingsRef;

   # Obtain the number of rings of each length.
   $ringCounts_ref = StructureControl::getRingCountsRef;
}
#elsif ($operation == 10) # Generate fragments.
#   {&generateFragments;}


#if ($operation != 10) # Open the output file. (Op. 10 has multiple outputs.)
#   {&openOutput;}
&openOutput; # Open the output file for all cases.


# Print the results.
if ($operation == 1)
   {&printBallAndStick;}
elsif ($operation == 2)
   {&printBondAngles;}
elsif ($operation == 3)
   {&printBondLengths;}
elsif ($operation == 4)
   {&printBondOO;}
elsif ($operation == 5)
   {&printBondDX;}
elsif ($operation == 6)
   {&printBondStats;}
elsif ($operation == 7)
   {&printCoordinationData;}
elsif ($operation == 8)
   {&printOpenScad(0);}
elsif ($operation == 9)
   {&printOpenScad(1);}
elsif ($operation == 11)
   {&printVTKBallAndStick;}
elsif ($operation == 12)
   {&printQnDistribution;}
elsif ($operation == 13)
   {&printRingDistribution;}
#elsif ($operation == 10)
#   {&printFragments;}


###############################################
# End program execution #######################
###############################################


sub initEnv
{
   # Assume that we will be using the olcao.skl type of data input.
   $inFile = "olcao.skl";

   # Assume that the default output file will be ok.  (Assigned automatically).
   $outFile = "bondAnalysis";

   # Assume the name for the bond order raw data file.
   $bondOrderFile = "S1__S1.dat";

   # Assume the default limit distance.
   $limitDist = 4.0;

   # Assume that we will compute bond lengths.
   $operation = 3;

   # Assume a default bonding factor that is 10% greater than the sum of the
   #   covalent radii.
   $bondingFactor = 1.1;

   # Assume that we will use x,y,z direct space coordinates for the atomic
   #   positions.
   $coordType = 3;

   # Assume that the Ylm for the bond orientational order is l=6.
   $Ylm_l = 6;

   # Assume a scaling factor of 10.0 for the atom and cell size so that 1.0
   #   angstrom is equal to 10.0mm.
   $aScale = 10.0;
   $cScale = 12.0;

   # The scaling factor for the bond diameter is set equal to 1.0 so that when
   #   the default bond diameter of 10% of the largest covalent radius is
   #   computed that is what will be used.
   $bScale = 1.0;

   # Assume that the font size will be scaled to be 0.9 times the radius of
   #   the bond cylinder.
   $fScale = 0.9;

   # Set the bond ratio between the bond radius and the covalent radius.
   $bondRadiusScale = 0.1;

   # Set the default volume to be 5% less than the max volume of the Prusa
   #   Mendle model 3D printer (measured in mm).
   $xVol3D = 150.0;
   $yVol3D = 150.0;
   $zVol3D = 150.0;

   # Initialize the bounding box to include the whole cell.
   $boxBorders[1][1] = 0.0;
   $boxBorders[1][2] = "max";
   $boxBorders[2][1] = 0.0;
   $boxBorders[2][2] = "max";
   $boxBorders[3][1] = 0.0;
   $boxBorders[3][2] = "max";
   $zone = 1; #Inside the box.

   # Assume that a histogram will not be created, and that if one is asked
   #   for, that the spacing will be 0.1.
   $doHist = 0;
   $histDelta = 0.1;

   # Assume for the Q^n analysis that the bridging atom is oxygen and that the
   #   main cation is silicon.
   $bridges[0] = "o";
   $ions[0] = "si";

   # Assume that our bond analysis is purely geometric and does not use OLCAO
   #   bond order data.
   $useOLCAOBO = 0;

#   # Assume that we will not be generating any fragments.
#   $doFrag = 0;
#
#   # Assume a chain length for any requested fragments.
#   $chainLength = 3;

   # Initialize the element data from the database.
   ElementData::initElementData;
}



sub parseCommandLine
{
   # Initialize the index counter for the command line parameters.
   my $number=0;
   my $index=0;
   my $nextTag;

   # Loop through the command line parameters checking for each option.
   while ($number < scalar(@ARGV))
   {
      if ($ARGV[$number] eq "-o")
         {$outFile = $ARGV[++$number];}
      elsif ($ARGV[$number] eq "-i")
         {$inFile = $ARGV[++$number];}
      elsif ($ARGV[$number] eq "-s")
         {$useOLCAOBO = 1;}
      elsif ($ARGV[$number] eq "-dist")
         {$limitDist = $ARGV[++$number];}
      elsif ($ARGV[$number] eq "-bs")  #Ball and stick.
         {$operation = 1;}
      elsif ($ARGV[$number] eq "-vtk")  #VTK ball and stick.
         {$operation = 11;}
      elsif ($ARGV[$number] eq "-ba")  #Bond angles.
         {$operation = 2;}
      elsif ($ARGV[$number] eq "-bl")  #Bond lengths.
         {$operation = 3;}
      elsif ($ARGV[$number] eq "-boo") #Bond orientational order.
      {
         $operation = 4;
         if (($number+1<scalar(@ARGV)) && ($ARGV[$number+1] eq "-Ylm_l"))
            {$Ylm_l = $ARGV[++$number];}
      }
      elsif ($ARGV[$number] eq "-dx")  #Open DX.
         {$operation = 5;}
      elsif ($ARGV[$number] eq "-st")  #Statistics.
         {$operation = 6;}
      elsif ($ARGV[$number] eq "-co")  #Coordination
         {$operation = 7;}
      elsif ($ARGV[$number] eq "-qn")  #Q^n distribution
      {
         $operation = 12;
         foreach $index (1..2)
         {
            if ($number+1 > $#ARGV)
               {last;}

            $nextTag = $ARGV[++$number];

            if ($nextTag eq "-b")
               {@bridges = StructureControl::prepLine("",
                     lc($ARGV[++$number]),'\s+');}
            elsif ($nextTag eq "-i")
               {@ions = StructureControl::prepLine("",
                     lc($ARGV[++$number]),'\s+');}
            else
               {$number--;last;}
         }
      }
      elsif ($ARGV[$number] eq "-rn")  # Ring distribution
      {
         $operation = 13;
         $minRingLen = $ARGV[++$number];
         $maxRingLen = $ARGV[++$number];
         if ($minRingLen =~ /-/)
            {print STDOUT "$minRingLen must be an integer.\n"; exit;}
         if ($maxRingLen =~ /-/)
            {print STDOUT "$maxRingLen must be an integer.\n"; exit;}
      }
      elsif ($ARGV[$number] eq "-3dfull")  #Full OpenScad Model
      {
         $operation = 8;
         foreach $index (1..3)
         {
            if ($number+1 > $#ARGV)
               {last;}

            $nextTag = $ARGV[++$number];

            if ($nextTag eq "-a")
               {$aScale = $ARGV[++$number];}
            elsif ($nextTag eq "-b")
               {$bScale = $ARGV[++$number];}
            elsif ($nextTag eq "-c")
               {$cScale = $ARGV[++$number];}
            elsif ($nextTag eq "-r")
               {$bondRadiusScale = $ARGV[++$number];}
            else
               {$number--;last;}
         }
      }
      elsif ($ARGV[$number] eq "-3dparts")  #Component-wise OpenScad Models.
      {
         $operation = 9;
         foreach $index (1..4)
         {
            if ($number+1 > $#ARGV)
               {last;}

            $nextTag = $ARGV[++$number];

            if ($nextTag eq "-a")
               {$aScale = $ARGV[++$number];}
            elsif ($nextTag eq "-b")
               {$bScale = $ARGV[++$number];}
            elsif ($nextTag eq "-c")
               {$cScale = $ARGV[++$number];}
            elsif ($nextTag eq "-r")
               {$bondRadiusScale = $ARGV[++$number];}
            elsif ($nextTag eq "-vol")
            {
               $xVol3D = $ARGV[++$number];
               $yVol3D = $ARGV[++$number];
               $zVol3D = $ARGV[++$number];
            }
            else
               {$number--;last;}
         }
      }
      elsif ($ARGV[$number] eq "-bf")
         {$bondingFactor = $ARGV[++$number];}
      elsif ($ARGV[$number] eq "-xyz")
         {$coordType=1;}
      elsif ($ARGV[$number] eq "-abc")
         {$coordType=2;}
      elsif ($ARGV[$number] eq "-fract")
         {$coordType=3;}
      elsif ($ARGV[$number] eq "-box")
      {
         $boxBorders[1][1] = $ARGV[++$number];
         $boxBorders[1][2] = $ARGV[++$number];
         $boxBorders[2][1] = $ARGV[++$number];
         $boxBorders[2][2] = $ARGV[++$number];
         $boxBorders[3][1] = $ARGV[++$number];
         $boxBorders[3][2] = $ARGV[++$number];
         $zone = $ARGV[++$number];
      }
      elsif ($ARGV[$number] eq "-hist")
      {
         $doHist = 1;
         $histDelta = $ARGV[++$number];
      }
#      elsif ($ARGV[$number] eq "-frag")
#      {
#         $operation = 10;
#         foreach $index (1..1)
#         {
#            if ($number+1 > $#ARGV)
#               {last;}
#
#            $nextTag = $ARGV[++$number];
#
#            if ($nextTag eq "-c")
#               {$chainLength = $ARGV[++$number];}
#            else
#               {$number--;last;}
#         }
#      }
      elsif ($ARGV[$number] eq "-help")
         {&printHelp;}
      else
      {
         print STDOUT "UNKNOWN COMMAND LINE PARAMETER $ARGV[$number].";
         print STDOUT " ABORTING.\n";
         exit;
      }

      $number++;
   }

   # Record the command line used to run this job.
   open (COMMANDLINE,">>command");
   print COMMANDLINE "bondAnalysis ";
   foreach my $argument (0..$#ARGV)
      {print COMMANDLINE "$ARGV[$argument] ";}
   print COMMANDLINE "\n";
   close (COMMANDLINE);
}


#sub generateFragments
#{
#   # Define local variables.
#   my $currElementSpecies;
#   my $found;
#   my $tag;
#   my @fragmentData;
#
#   # There will be one fragment generated for each unique element-species tag.
#   #   First, we initialize the count of unique fragments to zero.
#   $numUniqueFragments = 0;
#
#   # Search all atoms for H atoms and then check if it is bound to a unique
#   #   element-species.
#   foreach $atom (1..$numAtoms)
#   {
#      # If this is not an H atom, then skip to the next atom.
#      if ($atomElementName_ref->[$atom] ne "h")
#         {next;}
#
#      # Determine the element-species designation for the atom that is bonded
#      #   to this current H atom.
#      $currElementSpecies =
#            "$atomElementName_ref->[$bondedList_ref->[$atom][1]]" . 
#            "$atomSpeciesID_ref->[$bondedList_ref->[$atom][1]]";
#
#      # Determine if this elementSpecies tag is unique.
#      $found = 0;
#      foreach $tag (1..$numUniqueFragments)
#      {
#         if ($currElementSpecies eq $fragmentTagList[$tag])
#            {$found = $tag; last;}
#      }
#
#      # In the event that this is a unique element-species, then we record that
#      #   we found a unique element-species and then we make a fragment.
#      if ($found == 0)
#      {
#         $numUniqueFragments++;
#         $fragmentTagList[$numUniqueFragments] = $currElementSpecies;
#         StructureControl::generateUniqueFragment($atom,$chainLength,
#               $numUniqueFragments);
#      }
#   }
#}


sub openOutput
{
   # Check if the output file name was not assigned via the command line.
   if ($outFile eq "bondAnalysis")
   {
      # Use the default name if it wasn't assigned.
      if ($operation == 1)
         {$outFile = $outFile . ".bs";}
      elsif ($operation == 2)
         {$outFile = $outFile . ".ba";}
      elsif ($operation == 3)
         {$outFile = $outFile . ".bl";}
      elsif ($operation == 4)
         {$outFile = $outFile . ".boo";}
      elsif ($operation == 5)
         {$outFile = $outFile . ".bx";}
      elsif ($operation == 6)
         {$outFile = $outFile . ".st";}
      elsif ($operation == 7)
         {$outFile = $outFile . ".co";}
      elsif ($operation == 8)
         {$outFile = $outFile . ".scad";}
      elsif ($operation == 11)
         {$outFile = $outFile . ".vtk";}
      elsif ($operation == 12)
         {$outFile = $outFile . ".qn";}
      elsif ($operation == 13)
         {$outFile = $outFile . ".rn";}
   }

   # If making a histogram then open the associated output file.
   if ($doHist == 1)
   {
      # Only applies to certain output types.
      if (($operation == 2) || ($operation == 3))
      {
         open (OUTHIST,">$outFile.hist") ||
               die "Cannot open $outFile.hist for writing\n";
      }
   }

   # Only open the outFile if we will not make a different set later.
   if ($operation != 9)
      {open (OUT,">$outFile") || die "Cannot open $outFile for writing\n";}
}


sub printBallAndStick
{
   # Declare local variables.
   my $atom;
   my $bond;

   # Print the cell parameters.
   print OUT "Cell parameters:\n";
   print OUT "@{$realLattice_ref->[1]} ax ay az\n";
   print OUT "@{$realLattice_ref->[2]} bx by bz\n";
   print OUT "@{$realLattice_ref->[3]} cx cy cz\n";
 
   # Print the number of atoms in the model.
   print OUT "Number of atoms:  $numAtoms\n";

   # Print data for each atom.
   printf OUT "%s%s%s%s"," Atom # ",
                         " Elem. ",
                         "            $coordLabel            ",
                         " Bonded atom #s\n";
   foreach $atom (1..$numAtoms)
   {
      # Print the atom name and coordinate position information.
      printf OUT "%8d",$atom;
      printf OUT "%3s%-5d%12.5e %12.5e %12.5e",$atomElementName_ref->[$atom],
            $atomSpeciesID_ref->[$atom],$coords_ref->[$atom][1],
            $coords_ref->[$atom][2],$coords_ref->[$atom][3];

      # Print the atom numbers that this atom is bonded to.
      foreach $bond (1..$numBonds_ref->[$atom])
         {printf OUT " %5d",$bondedList_ref->[$atom][$bond];}

      # Finish the line.
      print OUT "\n";
   }
}


sub printVTKBallAndStick
{
   # Declare local variables.
   my $atom;
   my $bond;
   my @angstCoords;
   my @vtkBondList;
   my $totalNumBonds;
   my $totalBondPoints;
   my $totalVertPoints;
   my $atomCIndex;
   my $firstBondAtom;
   my $secondBondAtom;
   my @colorRGB;
   my $bohrRad;
   
   $bohrRad = StructureControl::getBohrRad;

   # Print the header.
   print OUT <<HEADER;
# vtk DataFile Version 4.2
This is a model produced by the OLCAO program suite: bondAnalysis program
ASCII
DATASET POLYDATA

HEADER

   # Print the positions of all atoms in the cell.
   print OUT "POINTS $numAtoms float\n";
   foreach $atom (1..$numAtoms)
   {
      @angstCoords[1] = $coords_ref->[$atom][1] / $bohrRad;
      @angstCoords[2] = $coords_ref->[$atom][2] / $bohrRad;
      @angstCoords[3] = $coords_ref->[$atom][3] / $bohrRad;
      print OUT "@angstCoords[1..3]\n";
   }
   print OUT "\n";

   # Now, list the connections bewtween the data points (POINTS) as LINES
   #   in the vtk file. The header of this section must include the number
   #   of lines, followed by the total number of data points in the section
   #   used to express those lines. So, if we are only using the number of
   #   points per line, and the start and end points, then we have 3x the
   #   number of bonds for the total number.
   
   $totalNumBonds = 0;
   foreach $atom (1..$numAtoms)
   {
      foreach $bond (1..$numBonds_ref->[$atom])
      {
         # Avoid double listing bonds by only printing those where the index
         #    number for atom one is less than the index number for atom 2.
         if ($atom < $bondedList_ref->[$atom][$bond])
         {
            # Store the line and increment the total count of bonds.
            $firstBondAtom = $atom - 1; # -1 because VTK arrays start at 0.
            $secondBondAtom = $bondedList_ref->[$atom][$bond] - 1; # -1 same.
            $vtkBondList[$totalNumBonds] =
                  "2 $firstBondAtom $secondBondAtom\n";
            $totalNumBonds++;
         }
      }
   }

   $totalBondPoints = $totalNumBonds * 3;
   print OUT "LINES $totalNumBonds $totalBondPoints\n";
   foreach $bond (0..$totalNumBonds-1)
      {print OUT "$vtkBondList[$bond]";}
   print OUT "\n";

   # Now here is where we need to include the additional information to
   #   display the model in legacy vtk format. This next section marks 
   #   the atom positions from the POINTS section as vertices in vtk. 
   #   Marking them as vertices allows programs like Paraview or just VTK
   #   to apply glyphs to them, and for the purposes of this program, we
   #   will need to apply spherical glyphs using a filter made for Paraview
   #   once this program has run. The VERTICES header must include, the
   #   number of vertices and the number of data points used to express
   #   them, which is only the number of vertices followed by the index
   #   number of each atom on every line, so 2x the number of vertices.

   $totalVertPoints = 2 * $numAtoms;
   print OUT "VERTICES $numAtoms $totalVertPoints\n";
   foreach $atom (1..$numAtoms)
   {
      # For our purposes, we will treat "cells" and "points" as the same
      #   thing. For now, we do not need to specify "CELL_DATA" in this
      #   calculation, so treating them as such saves time. But this should
      #   be fixed later, for more advanced and accurate visualization.
      # We need to attach a vertex to each point/atom we have. To do this,
      #   we need to specify the number of points, and the index number of
      #   that point. Since C arrays start at zero, we must start from
      #   there. Attempts to use in Paraview can sometimes be "hit or
      #   miss" when applying glyphs to vertices. If spherical glyphs are
      #   not applying to one or more of your vertices, change this next
      #   print line to a number higher than "1" as a quick fix. This note
      #   should be added as a printed suggestion whenever this subroutine
      #   is run, in the future.
      $atomCIndex = $atom - 1; # Again, -1 because of C arrays.
      print OUT "1 $atomCIndex\n";
   }
   print OUT "\n";

   # This final section adds the specified color table to the bonds and
   #   atoms. The color tables for VTK may be left as default, or you may
   #   construct a color table and specify how its used. Each entry in the
   #   lookup table is a rgba array (red green blue alpha) where alpha is
   #   tranparency. To save time, I will be using the default color table
   #   just to finish the VTK file. But in the future a color table should
   #   be generated in each file, specifying what color is associated with
   #   what type of atom or what strength of bond. Someone with more time
   #   on their hands should be able to peruse the legacy file
   #   specifications and add this function to the subroutine later on.
   print OUT "POINT_DATA $numAtoms\n";
   #print OUT "SCALARS sample_scalars float\n";
   #print OUT "LOOKUP_TABLE default\n";

   # This section will attempt to apply a scaling factor to spherical glyphs
   #   applied to the vertices, based on the atomic radii.
   print OUT "SCALARS atomic_radius float\n";
   print OUT "LOOKUP_TABLE default\n";
   foreach $atom (1..$numAtoms)
      {print OUT "$atomCovalRadii_ref->[$atom]\n";}
   print OUT "\n";
   #print OUT "LOOKUP_TABLE default\n";
   
   # This section will, for now, store the charge transfer data as point
   #   data.
   print OUT "COLOR_SCALARS atom_colors 3\n";
   foreach $atom (1..$numAtoms)
   {
      $colorRGB[0] = $atomColorVTK_ref->[$atom][0] / 255.0;
      $colorRGB[1] = $atomColorVTK_ref->[$atom][1] / 255.0;
      $colorRGB[2] = $atomColorVTK_ref->[$atom][2] / 255.0;
      print OUT "@colorRGB[0..2]\n";
   }
   #print OUT "LOOKUP_TABLE default\n";
}


sub printBondAngles
{
   # Declare local variables.
   my $atom;
   my $bond1;
   my $bond2;
   my $bondedAtom1;
   my $bondedAtom2;
   my $currentBACount;
   my $bondAngle;
   my $maxBA;
   my $minBA;

   # For each atom print the bond angles between each possible pair of atoms,
   #   and also print the atom ID numbers for each pair. Also, gather
   #   statistics that will be useful for printing a histogram if asked.
   $maxBA = 0.0;
   $minBA = 360.0;
   foreach $atom (1..$numAtoms)
   {
      # Compare the position of this atom with the box the user defined (or the
      #   default).  This also considers if the user wanted only atoms inside
      #   the box or only outside.  The return value is 1 if the atom is out
      #   of the desired region and it is 0 if the atom is inside the desired
      #   region.
      if (StructureControl::itemOutOfBounds($atom,$coords_ref))
         {next;}

      # Print the number of bond angles for this atom.
      print OUT "$atom Num bond angles:  $numBondAngles_ref->[$atom]\n";

      # Initialize a count of the current bond angle.
      $currentBACount = 0;

      foreach $bond1 (1..$numBonds_ref->[$atom]-1)
      {
         # Get the central cell atom number of this bonded atom.
         $bondedAtom1 = $ext2CentralItemMap_ref->
                        [$bondedExtList_ref->[$atom][$bond1]];

         foreach $bond2 ($bond1+1..$numBonds_ref->[$atom])
         {
            # Increment the count of the number of bonds.
            $currentBACount++;

            # Get the central cell atom number of this bonded atom.
            $bondedAtom2 = $ext2CentralItemMap_ref->
                           [$bondedExtList_ref->[$atom][$bond2]];

            # Print the element name and species number of each atom in this
            #   bond set with the middle listed atom being the one at the
            #   vertex.
            printf OUT "%s%s %s%s %s%s ",
                  $atomElementName_ref->[$bondedAtom1],
                  $atomSpeciesID_ref->[$bondedAtom1],
                  $atomElementName_ref->[$atom],
                  $atomSpeciesID_ref->[$atom],
                  $atomElementName_ref->[$bondedAtom2],
                  $atomSpeciesID_ref->[$bondedAtom2];

            # Print the index number of the atoms in this bond with the middle
            #   listed atom being the one at the vertex.  Note that the number
            #   is in reference to the atoms in the central cell.
            printf OUT "%7d%7d%7d ",$bondedAtom1,$atom,$bondedAtom2;

            # Finally, print the bond angle.
            $bondAngle = $bondAnglesExt_ref->[$atom][$currentBACount];
            printf OUT "%16.8f\n",$bondAngle;

            # Compare this bond angle to the min and max observed so far.
            if ($bondAngle < $minBA)
               {$minBA = $bondAngle;}
            if ($bondAngle > $maxBA)
               {$maxBA = $bondAngle;}
         }
      }
   } # $numAtom

   # Once the traditional bond angle list has been created, now we compute the
   #   histogram if asked.
   if ($doHist == 1)
   {
      # Define the needed variables.
      my $numPoints;
      my $bucketNum;
      my $startPoint;
      my $currentPoint;
      my @histogram;

      # Compute the number of points in the histogram.
      $numPoints = int(($maxBA - $minBA) / $histDelta) + 1;

      # Initialize the histogram.
      foreach my $point (1..$numPoints)
         {$histogram[$point] = 0.0;}

      # Revisit all the atoms to produce the histogram of every bond angle.
      foreach $atom (1..$numAtoms)
      {
         # Compare the position of this atom with the box the user defined (or the
         #   default).  This also considers if the user wanted only atoms inside
         #   the box or only outside.  The return value is 1 if the atom is out
         #   of the desired region and it is 0 if the atom is inside the desired
         #   region.
         if (StructureControl::itemOutOfBounds($atom,$coords_ref))
            {next;}

         $currentBACount = 0;

         # Consider one bond.
         foreach $bond1 (1..$numBonds_ref->[$atom]-1)
         {
            # Consider each other bond.
            foreach $bond2 ($bond1+1..$numBonds_ref->[$atom])
            {
               # Get the bond angle of the current bond.
               $currentBACount++;
               $bondAngle = $bondAnglesExt_ref->[$atom][$currentBACount];

               # Compute which bucket in the histogram should be incremented.
               $bucketNum = int(($bondAngle - $minBA) / $histDelta) + 1;

               # Increment the histogram.
               $histogram[$bucketNum]++;
            }
         }
      } # $numAtoms

      # Now that the histogram has been computed. We print it.
      foreach my $bucket (1..$numPoints)
      {
         $startPoint = int($minBA);
         $currentPoint = $startPoint + $histDelta*($bucket-1);
         print OUTHIST "$currentPoint $histogram[$bucket]\n";
      }
      close (OUTHIST);
   }
}

sub printBondLengths
{
   # Declare local variables.
   my $atom;
   my $element;
   my $species;
   my $bond;
   my $bondedAtom;
   my $maxBL;
   my $minBL;
   my $bondLength;

   # Initialize the min/max BLs for potential use in making a histogram.
   $minBL = 100.0;
   $maxBL = 0.0;

   foreach $atom (1..$numAtoms)
   {
      # Compare the position of this atom with the box the user defined (or the
      #   default).  This also considers if the user wanted only atoms inside
      #   the box or only outside.  The return value is 1 if the atom is out
      #   of the desired region and it is 0 if the atom is inside the desired
      #   region.
      if (StructureControl::itemOutOfBounds($atom,$coords_ref))
         {next;}

      # Print the ID data, the coordination, and the number of bonds for
      #   this atom.
      printf OUT "%s%s%s%s %s%d\n",$atomElementName_ref->[$atom],
            $atomSpeciesID_ref->[$atom],"_",$atom,
            "Num_bonds:  ",$numBonds_ref->[$atom];

      # Print each bond for this atom.
      foreach $bond (1..$numBonds_ref->[$atom])
      {
         # Obtain the central cell atom number for the atom at the other end
         #   of the current bond.
         $bondedAtom = $ext2CentralItemMap_ref->
               [$bondedExtList_ref->[$atom][$bond]];

         $bondLength = $bondLengthExt_ref->[$atom][$bond];

         printf OUT "    %s%s%s%s %8.5f",
               $atomElementName_ref->[$bondedAtom],
               $atomSpeciesID_ref->[$bondedAtom],"_",$bondedAtom,$bondLength;

         if ($bond%4 == 0)
            {print OUT "\n";}

         # Now that the bond has been printed, we compute the bounds needed
         #   in case a histogram was asked for.
         if ($bondLength > $maxBL)
            {$maxBL = $bondLength;}
         if ($bondLength < $minBL)
            {$minBL = $bondLength;}
      }
      if ($numBonds_ref->[$atom]%4 != 0)
         {print OUT "\n";}
   }

   # Once the traditional bond length list has been created, now we compute the
   #   histogram if asked.
   if ($doHist == 1)
   {
      # Define the needed variables.
      my $numPoints;
      my $bucketNum;
      my $startPoint;
      my $currentPoint;
      my @histogram;

      # Compute the number of points in the histogram.
      $numPoints = int(($maxBL - $minBL) / $histDelta) + 1;
print STDOUT "min max numPts: $minBL $maxBL $numPoints\n";

      # Initialize the histogram.
      foreach my $point (1..$numPoints)
         {$histogram[$point] = 0.0;}

      # Revisit all the atoms to produce the histogram of every bond length.
      foreach $atom (1..$numAtoms)
      {
         # Compare the position of this atom with the box the user defined (or the
         #   default).  This also considers if the user wanted only atoms inside
         #   the box or only outside.  The return value is 1 if the atom is out
         #   of the desired region and it is 0 if the atom is inside the desired
         #   region.
         if (StructureControl::itemOutOfBounds($atom,$coords_ref))
            {next;}

         # Consider one bond.
         foreach $bond (1..$numBonds_ref->[$atom])
         {
            # Get the bond length of the current bond.
            $bondLength = $bondLengthExt_ref->[$atom][$bond];

            # Compute which bucket in the histogram should be incremented.
            $bucketNum = int(($bondLength - $minBL) / $histDelta) + 1;

            # Increment the histogram.
            $histogram[$bucketNum]++;
         }
      } # $numAtoms

      # Now that the histogram has been computed. We print it.
      foreach my $bucket (1..$numPoints)
      {
         $startPoint = int($minBL);
         $currentPoint = $startPoint + $histDelta*($bucket-1);
         print OUTHIST "$currentPoint $histogram[$bucket]\n";
      }
      close (OUTHIST);
   }
}

sub printCoordinationData
{
   # Declare local variables.
   my $atom;
   my $element;

   foreach $atom (1..$numAtoms)
   {
      # Compare the position of this atom with the box the user defined (or the
      #   default).  This also considers if the user wanted only atoms inside
      #   the box or only outside.  The return value is 1 if the atom is out
      #   of the desired region and it is 0 if the atom is inside the desired
      #   region.
      if (StructureControl::itemOutOfBounds($atom,$coords_ref))
         {next;}

      # Print the ID data, the coordination, and the number of bonds for
      #   this atom.
      printf OUT "%s%s%s%s %s\n",$atomElementName_ref->[$atom],
            $atomSpeciesID_ref->[$atom],"_",$atom,$coordination_ref->[$atom];
   }

   print OUT "\nELEMENT DATA for $numElements elements\n";

   foreach $element (1..$numElements)
   {
      printf OUT "%s %s\n",$elementList_ref->[$element],
            $coordinationSummary_ref->[$element];
   }
}

sub printQnDistribution
{
   # Declare local variables.
   my $n;
   my $atom;

   print OUT "ATOM Q^n $numQnAtoms\n";
   foreach $atom (1..$numAtoms)
   {
      if ($atomQn_ref->[$atom] != -1)
      {
         print OUT "$atom $atomElementName_ref->[$atom] ";
         print OUT "$atomQn_ref->[$atom]\n";
      }
   }

   print OUT "\nAbsolute Q^n\n";
   foreach $n (0..8)
      {print OUT "Q^$n $absoluteSysQn_ref->[$n]\n";}

   print OUT "\nFractional Q^n\n";
   foreach $n (0..8)
      {print OUT "Q^$n $fractionalSysQn_ref->[$n]\n";}

   print OUT "\nNetwork Connectivity\n";
   print OUT "$netConnQn\n";
}

sub printRingDistribution
{
   # Declare local variables.
   my $n;
   my $ring;
   my $ringLen;

   #print OUT "Ring Range: $minRingLen $maxRingLen\n";
   print OUT "LABEL : SEQUENCE_NUM : COL_LABELS\n";
   foreach $ringLen ($minRingLen..$maxRingLen)
   {
      #print OUT "Rings $ringLen\n";
      foreach $ring (1..$ringCounts_ref->[$ringLen])
      {
         print OUT "$ringLen", "_$ring : ";
         print OUT "@{$rings_ref->[$ringLen][$ring]} : TOTAL\n";
      }
   }
}

sub printBondOO
{
   #  Declare local variables.
   my $atom;
   my $bond;

   open (OUT,">$outFile") || die "Cannot open $outFile for writing\n";

   # Print the number of atoms in the model.
   print OUT "$numAtoms\n";

   # Print the data for each atom.
   foreach $atom (1..$numAtoms)
   {
      # Print the atom number and bond orientational order parameter.
      printf OUT "%10d %12.8f",$atom,$qOrder_ref->[$atom];

      # Finish the line.
      print OUT "\n";
   }

   close (OUT);
}

sub printBondDX
{
   # Declare local variables.
   my $atom;
   my $bond;
   my $reducedBondInfoExt_ref;
   my $reducedNumBondsExt;
   my @returnValue;

   # Print the atomic positions of all relevant atoms in the periodic system.
   print OUT "object 1 class array type float rank 1 shape 3 items ";
   print OUT "$numAtomsExt data follows\n";
   foreach $atom (1..$numAtomsExt)
   {
      printf OUT "%15.11f ",$coordsExt_ref->[$atom][1];
      printf OUT "%15.11f ",$coordsExt_ref->[$atom][2];
      printf OUT "%15.11f ",$coordsExt_ref->[$atom][3];
      print OUT "\n";
   }
   print OUT "\n";

   # Get the list of bonds to show.
   @returnValue = &getBondsToShow;
   $reducedBondInfoExt_ref = $returnValue[0];
   $reducedNumBondsExt = $returnValue[1];

   # Reduce all the atom numbers associated with each bond by 1 because OpenDX
   #   starts counting everything from 0.
   foreach $bond (1..$reducedNumBondsExt)
   {
      $reducedBondInfoExt_ref->[$bond][1]--;
      $reducedBondInfoExt_ref->[$bond][2]--;
   }

   # Print the bond pairs for all the relevant bonds in the periodic system.
   #   Note that the "- 1" is present because openDX starts counting from 0.
   #   Additionally, we count up the total number of bonds to be shown.
   print OUT "object 2 class array type int rank 1 shape 2 items ";
   print OUT "$reducedNumBondsExt data follows\n";
   foreach $bond (1..$reducedNumBondsExt)
   {
      print OUT "$reducedBondInfoExt_ref->[$bond][1] ";
      print OUT "$reducedBondInfoExt_ref->[$bond][2]\n";
   }
   print OUT "attribute \"ref\" string \"positions\"\n";
   print OUT "attribute \"element type\" string \"lines\"\n";
   print OUT "\n";

   # Now we list the values for those connections.  The values are all constant
   #   so that the bond lines are the same color.
   print OUT "object 3 class array type float rank 0 items ";
   print OUT "$reducedNumBondsExt data follows\n";
   foreach $bond (1..$reducedNumBondsExt)
      {print OUT "5\n";}  #Arbitrary value.
   print OUT "attribute \"dep\" string \"connections\"\n";
   print OUT "\n";

   # Finally we combine the components into a field with the name "bo" so that
   #   the bond order part of the openDX program can read it.
   print OUT <<BO;
object "bo" class field
component "positions" value 1
component "connections" value 2
component "data" value 3

BO

   #The DX file is complete now so we can end it.  It is important to
   #  note that the DX file format requires a blank line at the end.  So
   #  the \n\n *must* be there.
   print OUT "end\n\n";
}

sub printBondStats
{
   # Declare local variables.
   my $element;
   my $species;
   my $atom;

   # Print out statistics.
   print OUT "Element Statistics:\n";
   printf OUT "%s%s%s%s%s%s","   Element    ",
                             "   Avg. BL    ",
                             "   Avg. BA    ",
                             "  StdDV. BL   ",
                             "  StdDV. BA","\n";
   foreach $element (1..$numElements)
   {
      printf OUT "%3s%-10s","",$elementList_ref->[$element];
      printf OUT "%13.4e ",$avgElemBL[$element];
      printf OUT "%13.4e" ,$avgElemBA[$element];
      printf OUT "%13.4e ",$stdElemBL[$element];
      printf OUT "%13.4e" ,$stdElemBA[$element];
      print OUT "\n";
   }

   # Make space for the next data segment.
   print OUT "\n\n";
   
   print OUT "Species Statistics:\n";
   printf OUT "%s%s%s%s%s%s","   Species    ",
                             "   Avg. BL    ",
                             "   Avg. BA    ",
                             "  StdDV. BL   ",
                             "  StdDV. BA","\n";
   foreach $element (1..$numElements)
   {
      foreach $species (1..$numSpecies_ref->[$element])
      {
         printf OUT "%3s%-10s","",$speciesList_ref->[$element][$species];
         printf OUT "%13.4e ",$avgSpecBL[$element][$species];
         printf OUT "%13.4e" ,$avgSpecBA[$element][$species];
         printf OUT "%13.4e ",$stdSpecBL[$element][$species];
         printf OUT "%13.4e" ,$stdSpecBA[$element][$species];
         print OUT "\n";
      }
   }

   # Make space for the next data segment.
   print OUT "\n\n";
   
   print OUT "Atom Statistics:\n";
   printf OUT "%s%s%s%s%s%s","   Atom       ",
                             "   Avg. BL    ",
                             "   Avg. BA    ",
                             "  StdDV. BL   ",
                             "  StdDV. BA","\n";
   foreach $atom (1..$numAtoms)
   {
      if ($avgAtomBL[$atom] != -1)
      {
         printf OUT "%3s%-10s%i","",$atomElementName_ref->[$atom],$atom;
         printf OUT "%13.4e ",$avgAtomBL[$atom];
         printf OUT "%13.4e" ,$avgAtomBA[$atom];
         printf OUT "%13.4e ",$stdAtomBL[$atom];
         printf OUT "%13.4e" ,$stdAtomBA[$atom];
         print OUT "\n";
      }
   }

   close (OUT);
}


sub printOpenScad
{
   # Define passed parameters.
   my $doParts = $_[0];

   # Define local variables.
   my $xyz;
   my $atom;
   my $angle; # This is the angle at which the key is positioned & rotated.
   my $hemisphere;
   my $bond;
   my $out;
   my $sheet;
   my $numItemSheets;
   my $minAtomRadius;
   my $maxAtomRadius;
   my $maxXItems;
   my $maxYItems;
   my $xGridPos;
   my $yGridPos;
   my $xStepSize;
   my $yStepSize;
   my $startingItemNumber;
   my $lastItemNumberPrinted;
   my $bondRadius;
   my $maxBondLength;
   my $reducedBondInfoExt_ref;
   my $reducedNumBondsExt;
   my @point1XYZ;
   my @point2XYZ;
   my @returnValue;
   my @sheetPos1;
   my @sheetPos2;
   my @scaledCoords;
   my @scaledCoordsExt;
   my @scaledAtomRadius; # Scaled radius of each atom.
   my @atomBondCount; # This is a size [$numAtoms] array. Each value is the
                      #   current count of the number of bonds created for the
                      #   indexed atom.
   my @atomNumIndex; # An ordered index number for each of the atoms in the
                     #   extended list of atoms being printed.

   # The basic approach that is used in this subroutine is to simultaneously
   #   allow for two different model printing methods.  The first is to create
   #   a complete model (cell, atoms, bonds) that is all conjoined as one
   #   giant union in one single file.  The second is to create the model in a
   #   set of files where the components of the model are disassembled and
   #   printed as a set of sheets for manual assembly.

   # The first approach may not be easy to actually print although it looks
   #   nice on a computer screen.  The second approach should be easier to
   #   print but it will require manual assembly.

   # The basic algorithm for the first approach is relatively easy.  Use some
   #   elementary modules for depositing a sphere at any point in space and for
   #   depositing a rod (cylinder) at any point in space. Then create a module
   #   that will deposite every bond and each of the eight cell vectors in
   #   space and join them as a giant union (even though they may not be
   #   touching). Note that all the bonds and vectors are arranged as they
   #   would be found in the crystal model.  That is, they are not set up as
   #   sheets here. Do a similar thing for the atoms (spheres). That is, create
   #   a module that will print each of the spheres in space (not in sheets)
   #   and join them as a single union even though they don't touch. Finally,
   #   make a union of the bonds, vectors, and atoms.  The output is all in one
   #   single file.

   # The basic algorithm for the second approach is a bit more complicated.
   #   Here, the atoms and bonds will be built and layed out in a set of files.
   #   There will be a bunch of files for the atoms and a bunch for the bonds.
   #   After the 3D printer prints the model it will be assembled by gathering
   #   all the pieces together and putting the rods in the holes. The tricks
   #   are that (1) when the atoms are printed in sheets, they will all have
   #   to have holes in them in exactly the right places (angles); (2) after
   #   printing there will be a bunch of pieces that all look almost exactly
   #   the same. Thus, there will need to be labels on the pieces to
   #   distinguish them. There will need to be three types of labels. Each atom
   #   will need a label for the atom as a whole, then each hole on each atom
   #   will need a label. Finally, each bond (rod) will need a label on each
   #   end to identify which atom and which hole on which atom that end of the
   #   bond is supposed to go in to.  This makes life a bit tricky.
   # The approach that is used to make the holes in the atoms is to create the
   #   same structure of rods used in the "first approach" described above.
   #   That is, describe a structure with just the bonds and the cell vectors
   #   in their appropriate positions in the crystalline cell in space. Then,
   #   position each atom (one at a time) into that model in its appropriate
   #   place and take a difference so that holes are established in the sphere
   #   at the right angles. Then, move the atoms to their place in a sheet.
   #   In the openScad file, this sequence reads a bit inside out. So, put
   #   into the sheet the difference between an atom in its cell coordinates
   #   and the structure containing all the bonds and cell vectors.
   # For the labeling of the hole, an index number is used (1,2,3,...). The
   #   label is placed near the hole as an indentation in the sphere.
   # For labeling the atoms, an index symbol triplet is used (AAA,AAB,AAC,...,
   #   AAZ,AAa,AAb,AAc,...AAz,ABA,ABB,ABC,...zzz. This will accomodate up to
   #   52^3=140608 number of atoms in a given model. If this needs to be
   #   increased I think that this can be done with relative ease by making
   #   the string longer or by including 0..9 or other symbols or even other
   #   fonts.  The label is placed somewhere away from the holes and other
   #   labels.
   # For labeling the bonds, the combination of atom label and atom-hole label
   #   are used.

   # Scale the atomic coordinates.
   &scaleAtomicCoords(\@scaledCoords,\@scaledCoordsExt);

   # Compute the maximum and minimum atom radius.
   $minAtomRadius = 10000000;
   $maxAtomRadius = 0;
   foreach $atom (1..$numAtoms)
   {
      # Compute the scaled radius of the atom.
      $scaledAtomRadius[$atom] = $atomCovalRadii_ref->[$atom] * $aScale;

      # Determine the minimum radius so far.
      if ($scaledAtomRadius[$atom] < $minAtomRadius)
         {$minAtomRadius = $scaledAtomRadius[$atom];}

      # Determine the maximum radius so far.
      if ($scaledAtomRadius[$atom] > $maxAtomRadius)
         {$maxAtomRadius = $scaledAtomRadius[$atom];}
   }

   # Compute the radius of all of the bond cylinders.
   $bondRadius = 0;
   foreach $atom (1..$numAtoms)
   {
      if ($bondRadiusScale*$atomCovalRadii_ref->[$atom]*$aScale > $bondRadius)
         {$bondRadius = $bondRadiusScale*$atomCovalRadii_ref->[$atom]*$aScale;}
   }

   # Compute the final scaled radius.
   $bondRadius = $bondRadius * $bScale;

   # Get the list of bonds to show.
   @returnValue = &getBondsToShow;
   $reducedBondInfoExt_ref = $returnValue[0];
   $reducedNumBondsExt = $returnValue[1];

   # Scale the bond lengths.
   foreach $bond (1..$reducedNumBondsExt)
      {$reducedBondInfoExt_ref->[$bond][3] *= $cScale;}

   # Create an ordered sequence of the extended atom numbers associated with
   #   the set of bonds being shown. 
   $atom = 0;
   $reducedBondInfoExt_ref->[0][1] = 0;
   $reducedBondInfoExt_ref->[0][2] = 0;
   foreach $bond (1..$reducedNumBondsExt)
   {
      if ($reducedBondInfoExt_ref->[$bond][1] ==
          $reducedBondInfoExt_ref->[$bond-1][1])
         {next;}
      else
         {$atomNumIndex[$reducedBondInfoExt_ref->[$bond][1]] = ++$atom;}
   }
   foreach $bond (1..$reducedNumBondsExt)
   {
      if ($reducedBondInfoExt_ref->[$bond][2] ==
          $reducedBondInfoExt_ref->[$bond-1][2])
         {next;}
      else
         {$atomNumIndex[$reducedBondInfoExt_ref->[$bond][2]] = ++$atom;}
   }

   # Compute the scaled maximum bond length.
   $maxBondLength = 0;
   foreach $bond (1..$reducedNumBondsExt)
   {
      if ($reducedBondInfoExt_ref->[$bond][3] > $maxBondLength)
         {$maxBondLength = $reducedBondInfoExt_ref->[$bond][3];}
   }

   # Define fixed model variables.
   $angle = 53.7; # Fix the angle for the key.

#   # Scale the size of the cell rods for the system.
#   foreach $abc (1..3)
#   {
#      foreach $xyz (1..3)
#      {
#         $scaledRealLattice[$abc][$xyz] =
#            $realLattice_ref->[$abc][$xyz] * $cScale;
#      }
#   }

   # Print out the models in different ways according to whether we want the
   #   full model or the parts.
   if ($doParts == 0)
   {
      # Everything will be printed in one file (the already open OUT handle).

      # Print the module for making the rods.
      &printRodModule(\*OUT);

      # Print the module for making a sphere that is translated to a give point.
      &printTransSphereModule(\*OUT);

      # Print the module for making the bonds and cell vectors. Note that the
      #   1 flag near the end is for requesting that corner spheres be included
      #   in the print.  These should not be included when printing the bonds
      #   and vectors (BAV) as a skeleton for subtracting holes (as is done
      #   in the other "parts" section).
      &printBAVModule(\*OUT,$minAtomRadius,$maxAtomRadius,\@scaledCoords,
            \@scaledCoordsExt,$bondRadius,$reducedBondInfoExt_ref,
            $reducedNumBondsExt,\@atomNumIndex,1,$doParts);

      # Print the module for printing all of the atoms as a big union.
      &printUnionAtomsModule(\@scaledCoords,\@scaledAtomRadius,\*OUT);

      # Print the model.
      &printFullModel(\*OUT);

      # Close the OUT handle.
      close (OUT);
   }
   else
   {
      # Compute the font size for all labels.
      $fontSize = $bondRadius * $fScale;

      # We are going to print the sheets of atom hemispheres first.

      # Select the grid step size.
      $xStepSize = 2.0*$maxAtomRadius+0.5*$maxAtomRadius;
      $yStepSize = 2.0*$maxAtomRadius+0.5*$maxAtomRadius;

      # Determine the maximum number of atom hemispheres in the x and y
      #   directions based on the maximum atom radius.
      $maxXItems = floor($xVol3D/$xStepSize);
      $maxYItems = floor($yVol3D/$yStepSize);

      # Compute the number of sheets to print. The times 2 is because we will
      #   have one set of top and one set of bottom hemisphere sheets.
      $numItemSheets = ceil($numAtoms/($maxXItems*$maxYItems))*2;

      # Print the sheets of atom hemispheres. We will do the top first and
      #   then the bottom.
      foreach $hemisphere (1..2)
      {
         # Initialize the starting atom number for the first sheet.
         $startingItemNumber = 1;

         foreach $sheet (1..$numItemSheets)
         {
            # Open the file for this sheet.
            if ($hemisphere == 1)
            {
               open (OUT, "> atomTopSheet$sheet.scad") ||
                     die "Cannot open atomTopSheet$sheet.scad for writing\n";
            }
            else
            {
               open (OUT, "> atomBotSheet$sheet.scad") ||
                     die "Cannot open atomBotSheet$sheet.scad for writing\n";
            }

            # Set default facet values.
            print OUT ("\$fa=0.5; // default minimum facet angle\n");
            print OUT ("\$fs=0.5; // default minimum facet size\n");
   
            # Initialize the position for the hemispheres on the sheet in the
            #    x-y axis.
            $sheetPos1[1] = $maxAtomRadius;
            $sheetPos1[2] = $maxAtomRadius;
   
            # Initialize the count of our current position in the x-y grid.
            $xGridPos = 1;
            $yGridPos = 1;
   
            # Print the module for making rods.
            &printRodModule(\*OUT);
   
            # Print the module for making labels that will appear on the
            #   spheres.
            &printSphereLabelModule(\*OUT);
   
            # Print module for making a sphere that is translated to a given
            #   point.
            &printTransSphereModule(\*OUT);
   
            # Print module for making a key that is translated to a given
            #   point.
            &printTransKeyModule(\*OUT,$angle);
   
            # Print module for making a cube that is translated to a given
            #   point.
            &printTransSubCubeModule(\*OUT);
   
            # Print the module for making the bonds and vectors skeleton.  Note
            #   that the 0 flag on the end requests that no corner spheres be
            #   included in the definition of the skeleton.  The corner spheres
            #   will have to be explicitly requested later.
            &printBAVModule(\*OUT,$minAtomRadius,$maxAtomRadius,\@scaledCoords,
                  \@scaledCoordsExt,$bondRadius,$reducedBondInfoExt_ref,
                  $reducedNumBondsExt,\@atomNumIndex,0,$doParts);
   
            # Add each atom hemisphere to the sheet.
            foreach $atom ($startingItemNumber..$numAtoms)
            {
               # Adjust the height of the current atom on the sheet.
               #$sheetPos1[3] = $scaledAtomRadius[$atom];
               $sheetPos1[3] = 0;
   
               &addAtomToSheet(\*OUT,$atom,$scaledCoords[$atom],\@sheetPos1,
                     $scaledAtomRadius[$atom],$angle,$hemisphere);
   
               # Record that we have added an atom in the x-axis and update the
               #   position for the next atom.
               $xGridPos++;
               $sheetPos1[1] += $xStepSize;
   
               # If this puts us over the maximum number of cells in the x-axis
               #   direction of the grid, then reset the x-axis count, reset the
               #   grid position on the x-axis to the first cell, increment
               #   the y-axis grid position, and increment the y-axis sheet pos.
               if ($xGridPos > $maxXItems)
               {
                  $xGridPos = 1;
                  $sheetPos1[1] = $maxAtomRadius;
                  $yGridPos++;
                  $sheetPos1[2] += $yStepSize;
               }
   
               # If this takes us over the maximum number of cells in the y-axis
               #   direction of the grid, reset the y-axis count and start a new
               #   sheet. Then record the last atom printed so that the new
               #   sheet can start from the next atom.
               if ($yGridPos > $maxYItems)
               {
                  $yGridPos = 1;
                  $sheetPos1[2] = $maxAtomRadius;
                  $lastItemNumberPrinted = $atom;
                  last;
               }
   
               # Record the last atom number printed in case the current sheet
               #   finishes before it is full.
               $lastItemNumberPrinted = $atom;
            }
   
            # Close the OUT file for this sheet.
            close (OUT);
   
            # Set up the starting atom for the next sheet and abort if this
            #   sheet just happened to perfectly fit the number of atoms.
            $startingItemNumber = $lastItemNumberPrinted + 1;
            if ($startingItemNumber > $numAtoms)
               {last;}
         } # End sheet loop
      } # End hemisphere loop

      # Now we do the bonds.

      $sheetPos1[0] = 0;
      $sheetPos2[0] = 0;

      # Set the height of both end points of the bond rod on the sheet.
      $sheetPos1[3] = $bondRadius;
      $sheetPos2[3] = $bondRadius;

      # Select the grid step size.
      $xStepSize = 2.0*$bondRadius + 0.5*$bondRadius;
      $yStepSize = $maxBondLength + 0.05*$maxBondLength;

      # Determine the maximum number of bonds that can be laid in the x and y
      #   directions based on the bond radius and the maximum bond length.
      $maxXItems = floor($xVol3D/$xStepSize);
      $maxYItems = floor($yVol3D/$yStepSize);

      # Compute the number of sheets to print.
      $numItemSheets = ceil($numAtoms/($maxXItems*$maxYItems));

      # Initialize the starting item number for the first sheet.
      $startingItemNumber = 1;

      # Initialize the number of bonds that each atom has had printed so far.
      foreach $atom (1..$numAtoms)
         {$atomBondCount[$atom] = 0;}

       # Print the sheets.
      foreach $sheet (1..$numItemSheets)
      {
         # Open the file for this sheet.
         open (OUT, "> bondSheet$sheet.scad") ||
               die "Cannot open bondSheet$sheet.scad for writing\n";

         # Set default facet values.
         print OUT ("\$fa=0.5; // default minimum facet angle\n");
         print OUT ("\$fs=0.5; // default minimum facet size\n");

         # Initialize the end points for the first bond on the sheet in the
         #   x-y axis.
         $sheetPos1[1] = $bondRadius;
         $sheetPos1[2] = $bondRadius;
         $sheetPos2[1] = $bondRadius;
         $sheetPos2[2] = $bondRadius + $reducedBondInfoExt_ref->[1][3];

         # Initialize the count of our current position in the x-y grid.
         $xGridPos = 1;
         $yGridPos = 1;

         # Print the module for making rods.
         &printRodModule(\*OUT);

         # Print the module for making labels on the rods.
         &printRodLabelModule(\*OUT);

         # Add each bond to the sheet.
         foreach $bond ($startingItemNumber..$reducedNumBondsExt)
         {
            # Increment the number of bonds that each of the atoms connected by
            #   the current bond have had placed so far.
            $atomBondCount[$reducedBondInfoExt_ref->[$bond][1]]++;
            $atomBondCount[$reducedBondInfoExt_ref->[$bond][2]]++;

            # Print a scaled rod between these two cartesian points.
            &printRod(\@sheetPos1,\@sheetPos2,$bondRadius,0,0,\*OUT,
                  $atomNumIndex[$reducedBondInfoExt_ref->[$bond][1]],
                  $atomNumIndex[$reducedBondInfoExt_ref->[$bond][2]],
                  $atomBondCount[$reducedBondInfoExt_ref->[$bond][1]],
                  $atomBondCount[$reducedBondInfoExt_ref->[$bond][2]],2);

            # Record that we have added a bond in the x-axis and update the
            #   position for the next bond.
            $xGridPos++;
            $sheetPos1[1] += $xStepSize;
            $sheetPos2[1] += $xStepSize;

            # If this puts us over the maximum number of cells in the x-axis
            #   direction of the grid, then reset the x-axis count, reset the
            #   grid position on the x-axis to the first cell, increment
            #   the y-axis grid position, and increment the y-axis sheet pos.
            if ($xGridPos > $maxXItems)
            {
               $xGridPos = 1;
               $sheetPos1[1] = $bondRadius;
               $sheetPos2[1] = $bondRadius;
               $yGridPos++;
               $sheetPos1[2] += $yStepSize;
               $sheetPos2[2] += $yStepSize;
            }

            # If this takes us over the maximum number of cells in the y-axis
            #   direction of the grid, reset the y-axis count and start a new
            #   sheet. Then record the last bond printed so that the new sheet
            #   can start from the next atom.
            if ($yGridPos > $maxYItems)
            {
               $yGridPos = 1;
               $sheetPos1[2] = $bondRadius;
               $sheetPos2[2] = $bondRadius+$reducedBondInfoExt_ref->[$bond][3];
               $lastItemNumberPrinted = $bond;
               last;
            }

            # Record the last bond number printed in case the current sheet
            #   finishes before it is full.
            $lastItemNumberPrinted = $bond;
         }

         # Close the OUT file for this sheet.
         close (OUT);

         # Set up the starting bond for the next sheet and abort if this sheet
         #   just happened to perfectly fit the number of bonds.
         $startingItemNumber = $lastItemNumberPrinted + 1;
         if ($startingItemNumber > $reducedNumBondsExt)
            {last;}
      }
   }
}

sub printRodModule
{
   # Define passed paramters.
   my $out = $_[0];

   # Print out the modules that will be used to make individual rods.
   print $out "module rod(xPos,yPos,zPos,angle,xNormal,yNormal,zNormal,shift,";
   print $out "length,radius)\n";
   print $out "{\n";
   print $out "   translate(v=[xPos,yPos,zPos]) {\n";
   print $out "      rotate(a=angle, v=[xNormal,yNormal,zNormal]) {\n";
   print $out "         translate(v=[0,0,shift]) {\n";
#   print $out "            cylinder(h=length,r=radius,\$fn=50);}}}\n";
   print $out "            cylinder(h=length,r=radius);}}}\n";
   print $out "}\n";
}

sub printRodLabelModule
{
   # Define passed paramters.
   my $out = $_[0];

   # Print out the modules that will be used to make individual rods.
   print $out "module labeledRod(xPos,yPos,zPos,angle,xNormal,yNormal,";
   print $out "zNormal,shift,length,radius,atomLabel1,atomLabel2,";
   print $out "label1,label2)\n";
   print $out "{\n";
   print $out "   difference() {\n";
   print $out "      translate(v=[xPos,yPos,zPos]) {\n";
   print $out "         rotate(a=angle,v=[xNormal,yNormal,zNormal]) {\n";
   print $out "            translate(v=[0,0,shift]) {\n";
#   print $out "               cylinder(h=length,r=radius,\$fn=50);}}}\n";
   print $out "               cylinder(h=length,r=radius);}}}\n";

   print $out "      translate(v=[xPos,yPos+length-length*1/6,";
   print $out "zPos+radius/2]) {\n";
   print $out "         rotate(a=-90,v=[0,0,1]) {\n";
   print $out "            linear_extrude(radius) {\n";
   print $out "               text(atomLabel1,font=\"Hack\",size=$fontSize,";
   print $out "halign=\"center\", valign=\"center\");}}}\n";

   print $out "      translate(v=[xPos,yPos+length*1/6,";
   print $out "zPos+radius/2]) {\n";
   print $out "         rotate(a=-90,v=[0,0,1]) {\n";
   print $out "            linear_extrude(radius) {\n";
   print $out "               text(atomLabel2,font=\"Hack\",size=$fontSize,";
   print $out "halign=\"center\", valign=\"center\");}}}\n";

   print $out "      translate(v=[xPos,yPos+length-length*1/3,";
   print $out "zPos+radius/2]) {\n";
   print $out "         rotate(a=-90,v=[0,0,1]) {\n";
   print $out "            linear_extrude(radius) {\n";
   print $out "               text(label1,font=\"Hack\",size=$fontSize,";
   print $out "halign=\"center\", valign=\"center\");}}}\n";

   print $out "      translate(v=[xPos,yPos+length*1/3,";
   print $out "zPos+radius/2]) {\n";
   print $out "         rotate(a=-90,v=[0,0,1]) {\n";
   print $out "            linear_extrude(radius) {\n";
   print $out "               text(label2,font=\"Hack\",size=$fontSize,";
   print $out "halign=\"center\", valign=\"center\");}}}\n";

   print $out "   }\n";
   print $out "}\n";
}

# This module is essentially the same as the printRodModule except that instead
#   of printing a cylinder, this will create a requested number at the radius
#   of the targeted atom.  Thus, the number will appear on the surface of an
#   atom that has this number differenced out of it.
sub printSphereLabelModule
{
   # Define passed paramters.
   my $out = $_[0];

   # Print out the module that will be used to make a label for bond holes on
   #   an atom. This acts just like the rod module except it prints a number
   #   instead of a cylinder.
   print $out "module sphereLabel(xPos,yPos,zPos,angle,xNormal,yNormal,";
   print $out "zNormal,shift,distance,thickness,radius,label)\n";
   print $out "{\n";
   print $out "   translate(v=[xPos,yPos,zPos]) {\n";
   print $out "      rotate(a=angle, v=[xNormal,yNormal,zNormal]) {\n";
   print $out "         translate(v=[radius,radius,distance-thickness/2]) {\n";
   print $out "            linear_extrude(thickness) {\n";
   print $out "               text(label,font=\"Hack\",size=$fontSize,";
   print $out "halign=\"center\",valign=\"center\");}}}}\n";
   print $out "}\n";
}

sub printTransSphereModule
{
   # Define passed paramters.
   my $out = $_[0];

   # Print out the modules that will be used to make a translated sphere.
   print $out "module transSphere(xPos,yPos,zPos,radius)\n";
   print $out "{\n";
   print $out "   translate(v=[xPos,yPos,zPos]) {sphere(r=radius);}\n";
   print $out "}\n";
}

sub printTransKeyModule
{
   # Define passed parameters.
   my $out = $_[0];
   my $angle = $_[1];

   # Print out the modules that will be used to make a translated key.
   print $out "module transKey(xPos,yPos,zPos,length)\n";
   print $out "{\n";
   print $out "   translate(v=[xPos,yPos,zPos]) {\n";
   print $out "      rotate([0,0,$angle]) ".
         "{cube(size=length,center=true);}\n";
   print $out "   }\n";
   print $out "}\n";
}

sub printTransSubCubeModule
{
   # Define passed parameters.
   my $out = $_[0];

   # Print out the module that will be used to make a translated cube.
   print $out "module transSubCube(xPos,yPos,zPos,length)\n";
   print $out "{\n";
   print $out "   translate(v=[xPos,yPos,zPos]) ".
         "{cube(size=length,center=true);}\n";
   print $out "}\n";
}

# Print bonds and lattice vectors.
sub printBAVModule
{
   # Define passed paramters.
   my $out                    = $_[0];
   my $minAtomRadius          = $_[1];
   my $maxAtomRadius          = $_[2];
   my $scaledCoords_ref       = $_[3];
   my $scaledCoordsExt_ref    = $_[4];
   my $bondRadius             = $_[5];
   my $reducedBondInfoExt_ref = $_[6];
   my $reducedNumBondsExt     = $_[7];
   my $atomNumIndex_ref       = $_[8];
   my $doCornerSpheres        = $_[9];
   my $doParts                = $_[10];

   # Define local variables.
   my $i;
   my $j;
   my $abc;
   my $xyz;
   my $atom;
   my $bond;
   my @returnValue;
   my @point1ABC;
   my @point2ABC;
   my @point1XYZ;
   my @point2XYZ;
   my $label1;
   my $label2;
   my @atomBondCount; # This is a size [$numAtoms] array. Each value is the
                      #   current count of the number of bonds created for the
                      #   indexed atom.

   # Print out the module that is used to make the collection of bonds and
   #   lattice vectors as a single union.
   print $out "module bondsAndVectors()\n";
   print $out "{\n";
   print $out "   union()\n";
   print $out "   {\n";

   # Create a scaled set of rods that define the cell.
   foreach $abc (0..2)
   {
      foreach $i (0..1)
      {
         foreach $j (0..1)
         {
            # This will make ABC fractional points:
            #   Point1 = 0,0,0  0,0,1  0,1,0  0,1,1 for $abc=0
            #            0,0,0  1,0,0  0,0,1  1,0,1 for $abc=1
            #            0,0,0  0,1,0  1,0,0  1,1,0 for $abc=2
            #   Point2 = 1,0,0  1,0,1  1,1,0  1,1,1 for $abc=0
            #            0,1,0  1,1,0  0,1,1  1,1,1 for $abc=1
            #            0,0,1  0,1,1  1,0,1  1,1,1 for $abc=2
            $point1ABC[($abc+0)%3] = 0;
            $point1ABC[($abc+1)%3] = $i;
            $point1ABC[($abc+2)%3] = $j;
            $point2ABC[($abc+0)%3] = 1;
            $point2ABC[($abc+1)%3] = $i;
            $point2ABC[($abc+2)%3] = $j;

            # Convert the points from ABC fractional to XYZ cartesian.
            @point1XYZ = StructureControl::getDirectXYZPoint(@point1ABC);
            @point2XYZ = StructureControl::getDirectXYZPoint(@point2ABC);

            # Scale the locations of the lattice rod endpoints.
            foreach $xyz (1..3)
            {
               $point1XYZ[$xyz] = $cScale * $point1XYZ[$xyz];
               $point2XYZ[$xyz] = $cScale * $point2XYZ[$xyz];
            }

            # Print a scaled rod between these two cartesian points.
            &printRod(\@point1XYZ,\@point2XYZ,$bondRadius,$minAtomRadius,
                  $maxAtomRadius,$out,0,0,0,0,0);

            if ($doCornerSpheres == 1)
            {
               # Print a scaled sphere at each point. (To ensure connectivity.)
               &printSphere(\@point1XYZ,$minAtomRadius,$out);
               &printSphere(\@point2XYZ,$minAtomRadius,$out);
            }
         }
      }
   }

   # In the case that the model is not printed by parts, then simply create a
   #   bond in space for each bond.
   if ($doParts == 0)
   {
      foreach $bond (1..$reducedNumBondsExt)
      {
         # Identify the end points of the bond.
         foreach $xyz (1..3)
         {
            $point1XYZ[$xyz] =
                 $scaledCoordsExt_ref->[$reducedBondInfoExt_ref->
                 [$bond][1]][$xyz];
            $point2XYZ[$xyz] =
                 $scaledCoordsExt_ref->[$reducedBondInfoExt_ref->
                 [$bond][2]][$xyz];
         }

         # Ask for the bond to be printed.
         &printRod(\@point1XYZ,\@point2XYZ,$bondRadius,$minAtomRadius,
               $maxAtomRadius,$out,0,0,0,0,0);
      }
   }

   # If the model is being printed in parts, then labels need to be printed in
   #   addition to simply printing the bond in space. These labels are the
   #   labels that will appear on the spheres.
   else
   {
      # Initialize the number of bonds that each atom has had printed so far.
      foreach $atom (1..$numAtoms)
         {$atomBondCount[$atom] = 0;}

      # Iterate over all of the bonds in the system.
      foreach $bond (1..$reducedNumBondsExt)
      {
         # Identify the end points of the bond.
         foreach $xyz (1..3)
         {
            $point1XYZ[$xyz] = $scaledCoordsExt_ref->
                  [$reducedBondInfoExt_ref->[$bond][1]][$xyz];
            $point2XYZ[$xyz] = $scaledCoordsExt_ref->
                  [$reducedBondInfoExt_ref->[$bond][2]][$xyz];
         }

         # Increment the number of bonds that each of the atoms connected by
         #   the current bond have had placed so far.
         $atomBondCount[$reducedBondInfoExt_ref->[$bond][1]]++;
         $atomBondCount[$reducedBondInfoExt_ref->[$bond][2]]++;

         # Obtain the labels for the bonds (i.e. the bond count so far for both
         #   atoms in the bond.
         $label1 = $atomBondCount[$reducedBondInfoExt_ref->[$bond][1]];
         $label2 = $atomBondCount[$reducedBondInfoExt_ref->[$bond][2]];

         # This will make two numbers in space that are the bond numbers for
         #   the two atoms joined by this bond.
         &printRod(\@point1XYZ,\@point2XYZ,$bondRadius,$minAtomRadius,
               $maxAtomRadius,$out,
               $atomNumIndex_ref->[$reducedBondInfoExt_ref->[$bond][1]],
               $atomNumIndex_ref->[$reducedBondInfoExt_ref->[$bond][2]],
               $label1,$label2,1);
      }
   }

   # Close the union of bond and cell vector parts.
   print $out "   }\n";

   # Close the BAV module.
   print $out "}\n";
}

sub printUnionAtomsModule
{
   # Define passed parameters.
   my $scaledCoords_ref = $_[0];
   my $scaledAtomRadius_ref = $_[1];
   my $out = $_[2];

   # Define local variables.
   my $atom;

   print $out "module allAtoms()\n";
   print $out "{\n";
   print $out "   union()\n";
   print $out "   {\n";

   # Print all of the atoms.
   foreach $atom (1..$numAtoms)
      {&printSphere($scaledCoords_ref->[$atom],
       $scaledAtomRadius_ref->[$atom],$out);}

   # Close the union of atoms.
   print $out "   }\n";

   # Close the atom module.
   print $out "}\n";
}

sub printFullModel
{
   # Define passed parameters.
   my $out = $_[0];

   print $out "union()\n";
   print $out "{\n";
   print $out "   bondsAndVectors();\n";
   print $out "   allAtoms();\n";
   print $out "}\n";
}

sub scaleAtomicCoords
{
   # Define passed parameters.
   my $scaledCoords_ref = $_[0];
   my $scaledCoordsExt_ref = $_[1];

   # Define local variables.
   my $atom;
   my $xyz;

   # Scale the locations of all the atoms involved in the model.
   foreach $atom (1..$numAtoms)
   {
      foreach $xyz (1..3)
         {$scaledCoords_ref->[$atom][$xyz] =
          $cScale*$coords_ref->[$atom][$xyz];}
   }
   foreach $atom (1..$numAtomsExt)
   {
      foreach $xyz (1..3)
         {$scaledCoordsExt_ref->[$atom][$xyz] = 
          $cScale*$coordsExt_ref->[$atom][$xyz];}
   }
}

sub printRod
{
   # Define passed paramters.
   my $point1_ref = $_[0];
   my $point2_ref = $_[1];
   my $rodRadius  = $_[2];
   my $minSphereRadius = $_[3];
   my $maxSphereRadius = $_[4];
   my $out = $_[5]; # File handle
   my $atomLabel1 = $_[6];
   my $atomLabel2 = $_[7];
   my $label1 = $_[8];
   my $label2 = $_[9];
   my $labelCode = $_[10]; # 0=no labels; 1=labels on spheres; 2=labels on rods

   # Define local variables.
   my $xyz;
   my $rodLength;
   my $angle;
   my @shiftedPoint1;
   my @shiftedPoint2;
   my @normal;
   my $rodShift;
   my $labelThickness;
   my $labelDistance;

   # Compute the rod length between defined points.
   $rodLength = 0.0;
   foreach $xyz (1..3)
      {$rodLength += ($point2_ref->[$xyz] - $point1_ref->[$xyz])**2;}
   $rodLength = sqrt($rodLength);

   # Adjust the rod length so that it penetrates only so far into the sphere.
   #  Presently this is hard coded to go 1/3 of the way into the two atoms at
   #  either end of the bond.  This doesn't work perfectly for different sized
   #  atoms, but making it work perfectly is not easy to do at the moment.
   $rodLength = $rodLength - $minSphereRadius/3.0*2.0;

   # Compute the shift of the rod position so that the full assembly does not
   #   have touching rods.
   $rodShift = $minSphereRadius/3.0;

   # Compute the positions of the rod's endpoints when one endpoint is
   #   centered at the origin.
   foreach $xyz (1..3)
   {
      $shiftedPoint1[$xyz] = 0.0;
      $shiftedPoint2[$xyz] = $point2_ref->[$xyz] - $point1_ref->[$xyz];
   }

   # Compute the angle of rotation for the rod (noting that rotations are
   #   positive in the counterclockwise direction.
   if ((abs($shiftedPoint2[1]) < 0.00000001) &&
       (abs($shiftedPoint2[2]) < 0.00000001))
      {$angle=0;}
   else
   {
      $angle = -90.0 + atan2($shiftedPoint2[3],
            sqrt($shiftedPoint2[1]**2 + $shiftedPoint2[2]**2))*180.0/pi;
   }

   # Obtain the vector that is normal to the plane formed by following three
   #   points:  (1) The origin; (2) A point on the z-axis at a distance equal
   #   to the length of the rod; (3) The shifted end point of the rod.  Note
   #   that the leading zeros in the passed arrays are there because the
   #   subroutine works on array elements 1, 2, 3 instead of 0, 1, 2.
   @normal = StructureControl::getPlaneNormal([0,0,0,0],\@shiftedPoint2,
      [0,0,0,$rodLength]);

   # Use the rod module to print this rod by itself.  This is used for
   #   labelCode 0 and 1.
   if (($labelCode == 0) || ($labelCode == 1))
   {
      print $out "      rod($point1_ref->[1],$point1_ref->[2],";
      print $out "$point1_ref->[3],$angle,$normal[1],$normal[2],$normal[3],";
      print $out "$rodShift,$rodLength,$rodRadius);\n";
   }

   # If the labelCode is 1, then print the label number next to the rod
   #   (so that it will appear on the sphere when subtracted away).
   if ($labelCode == 1)
   {
      # Compute the label thickness. Because the label is positioned between
      #   the radii of the max and min spheres it is necessary to make the
      #   thickness just a bit larger so that it penetrates all sphere
      #   surfaces.
      $labelThickness = ($maxSphereRadius-$minSphereRadius)*1.3;
      if ($labelThickness == 0)
         {$labelThickness = $rodRadius;}

      # Compute the distance from the center of the sphere that the label
      #   should be positioned. The label must be positioned between the
      #   radii of the largest and smallest spheres so that it intersects
      #   with all sphere surfaces. Hence, the distance is tha average of
      #   the max and min sphere radii.
      $labelDistance = ($maxSphereRadius+$minSphereRadius)/2.0;

      # Print the appropriate labels for the holes for this bond rod.
      print $out "sphereLabel($point1_ref->[1],$point1_ref->[2],";
      print $out "$point1_ref->[3],$angle+10,$normal[1],$normal[2],";
      print $out "$normal[3],0,$labelDistance,$labelThickness,";
      print $out "$rodRadius,\"$label1\");\n";
      print $out "sphereLabel($point2_ref->[1],$point2_ref->[2],";
      print $out "$point2_ref->[3],$angle+190,$normal[1],$normal[2],";
      print $out "$normal[3],0,$labelDistance,$labelThickness,";
      print $out "$rodRadius,\"$label2\");\n";

      # In the special case that the first bond for this atom is being printed,
      #   then we must also print the atom label.
      if ($label1 == 1)
      {
         # Print the sphere label.
         print $out "sphereLabel($point1_ref->[1],$point1_ref->[2],";
         print $out "$point1_ref->[3],$angle-20,$normal[1],$normal[2],";
         print $out "$normal[3],0,$labelDistance,$labelThickness,";
         print $out "$rodRadius,\"$atomLabel1\");\n";
      }
      if ($label2 == 1)
      {
         # Print the sphere label.
         print $out "sphereLabel($point2_ref->[1],$point2_ref->[2],";
         print $out "$point2_ref->[3],$angle+160,$normal[1],$normal[2],";
         print $out "$normal[3],0,$labelDistance,$labelThickness,";
         print $out "$rodRadius,\"$atomLabel2\");\n";
      }
   }

   # Print labels onto the rods if requested.
   if ($labelCode == 2)
   {
      print $out "labeledRod($point1_ref->[1],$point1_ref->[2]," .
            "$point1_ref->[3],";
      print $out "$angle,$normal[1],$normal[2],$normal[3],$rodShift,";
      print $out "$rodLength,$rodRadius,\"$atomLabel1\",\"$atomLabel2\"," .
            "\"$label1\",\"$label2\");\n";
   }
}

sub printSphere
{
   # Define passed parameters.
   my $point_ref = $_[0];
   my $radius    = $_[1];
   my $out       = $_[2]; # File handle

   print $out "      transSphere($point_ref->[1],$point_ref->[2],";
   print $out "$point_ref->[3],$radius);\n";
}


sub printKey
{
   # Define passed parameters.
   my $point_ref = $_[0];
   my $radius    = $_[1];
   my $angle     = $_[2];
   my $out       = $_[3]; # File handle

   # Define local variables.
   my @keyPos;
   my $keySize;

   # Assign key size.
   $keySize = 1.00;

   # Compute key position.
   $keyPos[1] = $point_ref->[1] + $radius * cos($angle*pi/180.0);
   $keyPos[2] = $point_ref->[2] + $radius * sin($angle*pi/180.0);
   $keyPos[3] = $point_ref->[3];

   print $out "      transKey($keyPos[1],$keyPos[2],$keyPos[3],$keySize);\n";
}

sub printSubCube
{
   # Define passed parameters.
   my $point_ref  = $_[0];
   my $radius     = $_[1];
   my $hemisphere = $_[2]; # 1=Print Top, Sub Bottom; 2=Print Bottom, Sub Top
   my $out        = $_[3]; # File handle

   # Define local variables.
   my @cubePos;
   my $cubeSize;

   # Compute the cube position. Cube will be created centered at the origin.
   $cubePos[1] = $point_ref->[1];
   $cubePos[2] = $point_ref->[2];
   if ($hemisphere == 1)
      {$cubePos[3] = $point_ref->[3] - $radius;}
   else
      {$cubePos[3] = $point_ref->[3] + $radius;}

   # Compute the cube size. It should be just a tad larger than the sphere.
   $cubeSize = $radius*2.0 + 0.01*$radius;

   # Request a translated cube for subtraction.
   print $out "         transSubCube($cubePos[1],$cubePos[2],$cubePos[3],".
         "$cubeSize);\n";
}

sub addAtomToSheet
{
   # Define passed parameters.
   my $out = $_[0];
   my $atom = $_[1];
   my $atomPos_ref = $_[2];
   my $sheetPos_ref = $_[3];
   my $radius = $_[4];
   my $angle = $_[5];
   my $hemisphere = $_[6];

   # Define local variables.
   my $xyz;
   my @transVect;
   my $rotation;

   if ($hemisphere == 1)
      {$rotation = 0;}
   else
      {$rotation = 180;}

   # Compute the translation vector for the atom from its position within the
   #   cell to its position on the sheet.
   foreach $xyz (1..3)
      {$transVect[$xyz] = $sheetPos_ref->[$xyz] - $atomPos_ref->[$xyz];}

   # Now we need to translate the difference object that is taken between the
   #   atom and the skeleton.  The difference object will have holes in all the
   #   right places and it will be translated to the correct spot on the sheet.
   print $out "rotate([0,$rotation,0]) {\n";
   print $out "   translate(v=[$transVect[1],$transVect[2],$transVect[3]]) {\n";
   print $out "      difference() {\n   ";
   print $out "         union() {\n   ";
   &printSphere($atomPos_ref,$radius,$out);
   &printKey($atomPos_ref,$radius,$angle,$out);
   print $out "         }\n";
   print $out "         bondsAndVectors();\n";
   &printSubCube($atomPos_ref,$radius,$hemisphere,$out);
   print $out "      }\n";
   print $out "   }\n";
   print $out "}\n";
}


sub printPartsLattice
{
   # Define passed parameters.
   my $vectorRadius = $_[0];

   # Define local variables.
   my $i;
   my $j;
   my $abc;
   my $xyz;
   my $rodLength;
   my $rodLocation;
   my @point1ABC;
   my @point2ABC;
   my @point1XYZ;
   my @point2XYZ;

   # Initialize the location of the first lattice vector in the model file.
   #   This rod will be positioned so that it is $vectorRadius from the edge
   #   and centered $vectorRadius from the base.
   $rodLocation = $vectorRadius;

   # Create a scaled set of rods that define the cell and place them in a row.
   foreach $abc (0..2)
   {
      foreach $i (0..1)
      {
         foreach $j (0..1)
         {
            # This will make ABC fractional points:
            #   Point1 = 0,0,0  0,0,1  0,1,0  0,1,1 for $abc=0
            #            0,0,0  1,0,0  0,0,1  1,0,1 for $abc=1
            #            0,0,0  0,1,0  1,0,0  1,1,0 for $abc=2
            #   Point2 = 1,0,0  1,0,1  1,1,0  1,1,1 for $abc=0
            #            0,1,0  1,1,0  0,1,1  1,1,1 for $abc=1
            #            0,0,1  0,1,1  1,0,1  1,1,1 for $abc=2
            $point1ABC[($abc+0)%3] = 0;
            $point1ABC[($abc+1)%3] = $i;
            $point1ABC[($abc+2)%3] = $j;
            $point2ABC[($abc+0)%3] = 1;
            $point2ABC[($abc+1)%3] = $i;
            $point2ABC[($abc+2)%3] = $j;

            # Convert the points from ABC fractional to XYZ cartesian.
            @point1XYZ = StructureControl::getDirectXYZPoint(@point1ABC);
            @point2XYZ = StructureControl::getDirectXYZPoint(@point2ABC);

            # Scale the locations of the lattice vectors.
            foreach $xyz (1..3)
            {
               $point1XYZ[$xyz] = $cScale * $point1XYZ[$xyz];
               $point2XYZ[$xyz] = $cScale * $point2XYZ[$xyz];
            }

            # Determine the length of the rod.
            $rodLength = &getRodLength(\@point1XYZ,\@point2XYZ);

            # Define the location of the rod in the model.
            $point1XYZ[1] = $rodLocation;
            $point2XYZ[1] = $rodLocation;
            $point1XYZ[2] = 0.0;
            $point2XYZ[2] = $rodLength;
            $point1XYZ[3] = $vectorRadius;
            $point2XYZ[3] = $vectorRadius;

            # Print a scaled rod between these two cartesian points.
            #&printRod(\@point1XYZ,\@point2XYZ,$bondRadius,$minAtomRadius,
            #      $maxAtomRadius,$out,0,0);

            # Print a scaled sphere at each point.  (To ensure connectivity.)
#            &printSphere(\@point1XYZ,$bondRadius);
#            &printSphere(\@point2XYZ,$bondRadius);

            # Increment the position of the rodLocation for the next vector.
            $rodLocation += 2.2 * $vectorRadius;
         }
      }
   }
}

sub getRodLength
{
   # Define passed parameters.
   my $point1XYZ_ref = $_[0];
   my $point2XYZ_ref = $_[1];

   # Define local variables.
   my $length;

   # Compute the distance between the points.
   $length = sqrt(($point2XYZ_ref->[1] - $point1XYZ_ref->[1])**2 +
                  ($point2XYZ_ref->[2] - $point1XYZ_ref->[2])**2 +
                  ($point2XYZ_ref->[3] - $point1XYZ_ref->[3])**2);

   # Return the rod length.
   return ($length);
}

sub getBondsToShow
{
   # Declare local variables.
   my $atom;
   my $bond;
   my $numBondsExt;  # Note: until the end, this is one less than correct num.
   my $bondedAtom1;
   my $bondedAtom2;
   my @bondInfoExt;
   my @bondInfoExtTemp1;
   my @bondInfoExtTemp2;
   my $reducedNumBondsExt;
   my $reducedBond;
   my @reducedBondInfoExt;
   my $prev;
   my $numBondsBO;
   my $bondBO;
   my @bondBOList;
   my $line;
   my @values;
   my $found;

   # Prior to assembling the ordered list of bonded atoms with additional
   #   meta data, we will read in the bond order data if requested. This
   #   data will be used to further reduce the list of bonds to show.
   if ($useOLCAOBO == 1)
   {
      open (BO, "<$bondOrderFile")
            || die "Cannot open $bondOrderFile for reading.\n";

      # Read past the BO header.
      $line = <BO>;

      $numBondsBO = 0;
      while ($line = <BO>)
      {
         @values = StructureControl::prepLine("",$line,'\s+');
         $numBondsBO++;
         $bondBOList[$numBondsBO][0] = $values[2];
         $bondBOList[$numBondsBO][1] = $values[3];
      }

      close(BO);
   }

   # Extract all the bonds to be shown and count them up along the way.
   $numBondsExt = -1; # Note that we start from -1 to fill array from 0.
   foreach $atom (1..$numAtoms)
   {
      # Get the atom number of the current atom in the extended cell list.
      $bondedAtom1 = $central2ExtItemMap_ref->[$atom];

      # Consider each bonded atom in turn.
      foreach $bond (1..$numBonds_ref->[$atom])
      {
         # Note that initially this double counts bonds between atoms that
         #   are both in the central cell.
         $numBondsExt++; # Note, first bond is number 0. This is necessary
                         # for the sorting process that is done later.

         # Recall that the value in bondedExtList_ref is in reference to the
         #   ext cell while the referencing index ($atom) is in reference to
         #   the central cell.  That is why we don't need the
         #   central2ExtItemMap here.
         $bondedAtom2 = $bondedExtList_ref->[$atom][$bond];

         # Demand that the small atom number is listed first for comparison
         #   later to remove the double counts.
         if ($bondedAtom1 < $bondedAtom2)
         {
            $bondInfoExtTemp1[$numBondsExt][1] = $bondedAtom1;
            $bondInfoExtTemp1[$numBondsExt][2] = $bondedAtom2;
         }
         else
         {
            $bondInfoExtTemp1[$numBondsExt][1] = $bondedAtom2;
            $bondInfoExtTemp1[$numBondsExt][2] = $bondedAtom1;
         }

         # Record bond length info for this bond pair. Order doesn't matter.
         $bondInfoExtTemp1[$numBondsExt][3] =
               $bondLengthExt_ref->[$atom][$bond];
      }
   }

   # Sort the bonds according to the second bonded atom followed by a
   #   stable sort according to the first bonded atom so that bonds that
   #   are between identical atom pairs are next door.
   @bondInfoExtTemp2 = sort{$a->[2] <=> $b->[2]} @bondInfoExtTemp1;
   @bondInfoExt = sort{$a->[1] <=> $b->[1]} @bondInfoExtTemp2;

   # Now we need to remove duplicate bonds by simply recording any
   #   non-dups. We copy the first bond (in bondInfoExt) into the
   #   reducedBondInfoExt array. Then, loop from 1 to the number of bonds
   #   where the loop index refers to the *next* bond in the bondInfoExt
   #   list.
   # At the same time, we will only keep bonds that correspond to bonds
   #   listed in the bond order file if asked.
   #
   $reducedNumBondsExt = 0;
   foreach $bond (0..$numBondsExt-1)
   {
      # If we are limited only to bonds that are present in the bond order
      #   list, then we need to make sure that this bond is one of them.
      if ($useOLCAOBO == 1)
      {
         # Assume that the current bond is *not* present.
         $found = 0;
         foreach $bondBO (1..$numBondsBO)
         {
            if (($ext2CentralItemMap_ref->[$bondInfoExt[$bond][1]] ==
                  $bondBOList[$bondBO][0]) && 
               ($ext2CentralItemMap_ref->[$bondInfoExt[$bond][2]] ==
                  $bondBOList[$bondBO][1]))
            {
               $found = 1;
               last;
            }
         }

         # If the bond was not found, then we should not use it.
         if ($found == 0)
            {next;}
      }

      # We only reach here if the bond was found in the bond order list
      #   or if we are not using the bond order list at all. In either case
      #   we now search the reduced bond list to make sure that the
      #   current bond isn't a duplicate.
      $found = 0;
      foreach $reducedBond (1..$reducedNumBondsExt)
      {
         if (($bondInfoExt[$bond][1] ==
               $reducedBondInfoExt[$reducedBond][1]) &&
            ($bondInfoExt[$bond][2] ==
               $reducedBondInfoExt[$reducedBond][2]))
         {
            $found = 1;
            last;
         }
      }

      # If the bond was found, then it's a duplicate and we should not use it.
      #   Otherwise, we add it to the reduced list of bonds.
      if ($found == 1)
         {next;}
      else
      {
         # Found a non-duplicate bond. Record it in the reduced list.
         $reducedNumBondsExt++;
         $reducedBondInfoExt[$reducedNumBondsExt][1] = 
               $bondInfoExt[$bond][1];
         $reducedBondInfoExt[$reducedNumBondsExt][2] =
               $bondInfoExt[$bond][2];
         $reducedBondInfoExt[$reducedNumBondsExt][3] =
               $bondInfoExt[$bond][3];
      }
   }

   # Return a reference to the reduced bond info list (with numbers referencing
   #   the extended lattice).
   return (\@reducedBondInfoExt, $reducedNumBondsExt);
}


sub computeStatistics
{
   # Define local variables.
   my $atom;
   my $bond1;
   my $bond2;
   my $elemID;
   my $specID;
   my $element;
   my $species;
   my $warning;
   my @numTotalElemBonds;
   my @numTotalSpecBonds;
   my @numTotalAtomBonds;
   my @numTotalElemBondAngles;
   my @numTotalSpecBondAngles;
   my @numTotalAtomBondAngles;
   my @accumElemBondLength;
   my @accumSpecBondLength;
   my @accumAtomBondLength;
   my @accumElemBondAngle;
   my @accumSpecBondAngle;
   my @accumAtomBondAngle;
   my $numCurrBondAngle;

   # The goal here is to compute the mean and 1st standard deviation of the
   #   bond lengths (BLs) and bond angles (BAs) for each element, species, and
   #   atom.

   # Initialize a few counts to zero. The number of bonds for each element, the
   #   number of bond angles for each element, the accumulated bond length for
   #   each element, and the accumulated bond angle for each element.  Also,
   #   initialize to zero the same variables associated with each species of
   #   each element.  Initialize all the average values to be computed for each
   #   element and species to -1.
   foreach $element (1..$numElements)
   {
      $numTotalElemBonds[$element]      = 0;
      $numTotalElemBondAngles[$element] = 0;
      $accumElemBondLength[$element]    = 0;
      $accumElemBondAngle[$element]     = 0;
      $avgElemBL[$element] = -1;
      $avgElemBA[$element] = -1;

      foreach $species (1..$numSpecies_ref->[$element])
      {
         $numTotalSpecBonds[$element][$species]      = 0;
         $numTotalSpecBondAngles[$element][$species] = 0;
         $accumSpecBondLength[$element][$species]    = 0;
         $accumSpecBondAngle[$element][$species]     = 0;
         $avgSpecBL[$element][$species] = -1;
         $avgSpecBA[$element][$species] = -1;
      }
   }

   # Perform the same initialization for the data structures for each atom.
   foreach $atom (1..$numAtoms)
   {
      $numTotalAtomBonds[$atom]      = 0;
      $numTotalAtomBondAngles[$atom] = 0;
      $accumAtomBondLength[$atom]    = 0;
      $accumAtomBondAngle[$atom]     = 0;
      $avgAtomBL[$atom] = -1;
      $avgAtomBA[$atom] = -1;
   }

   foreach $atom (1..$numAtoms)
   {
      # Compare the position of this atom with the box the user defined (or the
      #   default).  This also considers if the user wanted only atoms inside
      #   the box or only outside.  The return value is 1 if the atom is out
      #   of the desired region and it is 0 if the atom is inside the desired
      #   region.
      if (StructureControl::itemOutOfBounds($atom,$coords_ref))
         {next;}

      # Get the elementID and speciesID numbers for this atom.
      $elemID = $atomElementID_ref->[$atom];
      $specID = $atomSpeciesID_ref->[$atom];

      # Consider each bond common to this atom.  Accumulate the number of bonds
      #   into three different divisions.  (1)  By atom; (2) By element;
      #   (3)  By species.  Also accumulate the bond length into the same three
      #   types of divisions.
      foreach $bond1 (1..$numBonds_ref->[$atom])
      {
         $numTotalAtomBonds[$atom]++;
         $numTotalElemBonds[$elemID]++;
         $numTotalSpecBonds[$elemID][$specID]++;
         $accumAtomBondLength[$atom] += $bondLengthExt_ref->[$atom][$bond1];
         $accumElemBondLength[$elemID] += $bondLengthExt_ref->[$atom][$bond1];
         $accumSpecBondLength[$elemID][$specID] +=
               $bondLengthExt_ref->[$atom][$bond1];
      }

      # Consider each bond pair (no double counting) with the current atom as
      #   the vertex of the triplet.  Accumulate the number of bond angles into
      #   three different divisions.  (1)  By atom;  (2) By element;
      #   (3)  By species.  Also accumulate the bond angles into the same three
      #   types of divisions.
      $numCurrBondAngle = 0;  # Reference bond angles in a flat list.
      foreach $bond1 (1..$numBonds_ref->[$atom]-1)
      {
         foreach $bond2 ($bond1+1..$numBonds_ref->[$atom])
         {
            $numCurrBondAngle++;
            $numTotalAtomBondAngles[$atom]++;
            $numTotalElemBondAngles[$elemID]++;
            $numTotalSpecBondAngles[$elemID][$specID]++;
            $accumAtomBondAngle[$atom] +=
                  $bondAnglesExt_ref->[$atom][$numCurrBondAngle];
            $accumElemBondAngle[$elemID] +=
                  $bondAnglesExt_ref->[$atom][$numCurrBondAngle];
            $accumSpecBondAngle[$elemID][$specID] +=
                  $bondAnglesExt_ref->[$atom][$numCurrBondAngle];
         }
      }
   }

   # Divide the accumulated bond length and bond angle for each element and
   #   species by the number of bonds or bond angles for that element or
   #   species.  This is the average.
   foreach $element (1..$numElements)
   {
      # Ensure that we do not divide by zero when computing the average bond
      #   length for this element.
      if ($numTotalElemBonds[$element] == 0)
         {&elementWarning($element,1);}
      else
         {$avgElemBL[$element] = $accumElemBondLength[$element] /
                                 $numTotalElemBonds[$element];}

      # Ensure that we do not divide by zero when computing the average bond
      #   angle for this element.
      if ($numTotalElemBondAngles[$element] == 0)
         {&elementWarning($element,2);}
      else
         {$avgElemBA[$element] = $accumElemBondAngle[$element] /
                                 $numTotalElemBondAngles[$element];}


      foreach $species (1..$numSpecies_ref->[$element])
      {
         # Ensure that we do not divide by zero when computing the average bond
         #   length for this species.
         if ($numTotalSpecBonds[$element][$species] == 0)
            {&speciesWarning($element,$species,1);}
         else
            {$avgSpecBL[$element][$species] =
                  $accumSpecBondLength[$element][$species] /
                  $numTotalSpecBonds[$element][$species];}


         # Ensure that we do not divide by zero when computing the average bond
         #   angle for this species.
         if ($numTotalSpecBondAngles[$element][$species] == 0)
            {&speciesWarning($element,$species,2);}
         else
            {$avgSpecBA[$element][$species] =
                  $accumSpecBondAngle[$element][$species] /
                  $numTotalSpecBondAngles[$element][$species];}
      }
   }

   # Do the same thing for each atom.
   foreach $atom (1..$numAtoms)
   {
      # Ensure that we do not divide by zero when computing the average bond
      #   length for this atom.
      if ($numTotalAtomBonds[$atom] == 0)
         {&atomWarning($atom,1);}
      else
         {$avgAtomBL[$atom] =
               $accumAtomBondLength[$atom] / $numTotalAtomBonds[$atom];}

      # Ensure that we do not divide by zero when computing the average bond
      #   angle for this atom.
      if ($numTotalAtomBondAngles[$atom] == 0)
         {&atomWarning($atom,2);}
      else
         {$avgAtomBA[$atom] =
               $accumAtomBondAngle[$atom] / $numTotalAtomBondAngles[$atom];}
   }


   # Compute std deviation.

   # Reinitialize to zero all the bond counts for elements and species.  In
   #   this case the accumulating arrays are used to accumulate the square of
   #   the difference between the bond length or bond angle and the just
   #   computed average value for the same.  This will be used to get the
   #   standard deviation for each element and species.  Initialize all the
   #   average values to be computed for each element and species to -1.
   foreach $element (1..$numElements)
   {
      $numTotalElemBonds[$element]      = 0;
      $numTotalElemBondAngles[$element] = 0;
      $accumElemBondLength[$element]    = 0;
      $accumElemBondAngle[$element]     = 0;
      $stdElemBL[$element] = -1;
      $stdElemBA[$element] = -1;

      foreach $species (1..$numSpecies_ref->[$element])
      {
         $numTotalSpecBonds[$element][$species]      = 0;
         $numTotalSpecBondAngles[$element][$species] = 0;
         $accumSpecBondLength[$element][$species]    = 0;
         $accumSpecBondAngle[$element][$species]     = 0;
         $stdSpecBL[$element][$species] = -1;
         $stdSpecBA[$element][$species] = -1;
      }
   }

   # Perform the same re-initialization for the data structures for each atom.
   foreach $atom (1..$numAtoms)
   {
      $numTotalAtomBonds[$atom]      = 0;
      $numTotalAtomBondAngles[$atom] = 0;
      $accumAtomBondLength[$atom]    = 0;
      $accumAtomBondAngle[$atom]     = 0;
      $stdAtomBL[$atom] = -1;
      $stdAtomBA[$atom] = -1;
   }

   foreach $atom (1..$numAtoms)
   {
      # Compare the position of this atom with the box the user defined (or the
      #   default).  This also considers if the user wanted only atoms inside
      #   the box or only outside.  The return value is 1 if the atom is out
      #   of the desired region and it is 0 if the atom is inside the desired
      #   region.
      if (StructureControl::itemOutOfBounds($atom,$coords_ref))
         {next;}

      # Get short names for the elementID and speciesID numbers for this atom.
      $elemID = $atomElementID_ref->[$atom];
      $specID = $atomSpeciesID_ref->[$atom];

      # Consider each bond common to this atom.  Accumulate the number of bonds
      #   into two different divisions.  (1)  By element;  (2)  By species.
      #   Also accumulate the square of the difference between the bond length
      #   and the average just computed above into the same two types of
      #   divisions.  This is done to distinguish later statistics by element
      #   and species.
      foreach $bond1 (1..$numBonds_ref->[$atom])
      {
         $numTotalAtomBonds[$atom]++;
         $numTotalElemBonds[$elemID]++;
         $numTotalSpecBonds[$elemID][$specID]++;
         $accumAtomBondLength[$atom] +=
               ($bondLengthExt_ref->[$atom][$bond1] -
                $avgAtomBL[$atom])**2;
         $accumElemBondLength[$elemID] +=
               ($bondLengthExt_ref->[$atom][$bond1] -
                $avgElemBL[$elemID])**2;
         $accumSpecBondLength[$elemID][$specID] +=
               ($bondLengthExt_ref->[$atom][$bond1] -
                $avgSpecBL[$elemID][$specID])**2;
      }


      # Consider each bond pair (no double counting) with the current atom as
      #   the vertex of the triplet.  Accumulate the number of bond angles into
      #   two different divisions.  (1)  By element;  (2)  By species.  Also
      #   accumulate the square of the difference between the bond angle and
      #   the just computed average into the same two types of divisions.
      $numCurrBondAngle = 0;  # Reference bond angles in a flat list.
      foreach $bond1 (1..$numBonds_ref->[$atom]-1)
      {
         foreach $bond2 ($bond1+1..$numBonds_ref->[$atom])
         {
            $numCurrBondAngle++;
            $numTotalAtomBondAngles[$atom]++;
            $numTotalElemBondAngles[$elemID]++;
            $numTotalSpecBondAngles[$elemID][$specID]++;
            $accumAtomBondAngle[$atom] +=
                  ($bondAnglesExt_ref->[$atom][$numCurrBondAngle] -
                   $avgAtomBA[$atom])**2;
            $accumElemBondAngle[$elemID] +=
                  ($bondAnglesExt_ref->[$atom][$numCurrBondAngle] -
                   $avgElemBA[$elemID])**2;
            $accumSpecBondAngle[$elemID][$specID] +=
                  ($bondAnglesExt_ref->[$atom][$numCurrBondAngle] -
                   $avgSpecBA[$elemID][$specID])**2;
         }
      }
   }

   # Divide the accumulated bond length and bond angle differences for each
   #   element and species by the number of bonds or bond angles for that
   #   element or species.  Take the square root and that is the first standard
   #   deviation.
   foreach $element (1..$numElements)
   {
      # Ensure that we do not divide by zero when computing the std.div. bond
      #   length for this element.
      if ($numTotalElemBonds[$element] == 0)
         {&elementWarning($element,1);}
      else
         {$stdElemBL[$element] = sqrt($accumElemBondLength[$element] /
                                      $numTotalElemBonds[$element]);}

      # Ensure that we do not divide by zero when computing the std.div. bond
      #   angle for this element.
      if ($numTotalElemBondAngles[$element] == 0)
         {&elementWarning($element,2);}
      else
         {$stdElemBA[$element] = sqrt($accumElemBondAngle[$element] /
                                      $numTotalElemBondAngles[$element]);}

      foreach $species (1..$numSpecies_ref->[$element])
      {
         # Ensure that we do not divide by zero when computing the average bond
         #   length for this species.
         if ($numTotalSpecBonds[$element][$species] == 0)
            {&speciesWarning($element,$species,1);}
         else
            {$stdSpecBL[$element][$species] =
                   sqrt($accumSpecBondLength[$element][$species] /
                   $numTotalSpecBonds[$element][$species]);}


         # Ensure that we do not divide by zero when computing the average bond
         #   angle for this species.
         if ($numTotalSpecBondAngles[$element][$species] == 0)
            {&speciesWarning($element,$species,2);}
         else
            {$stdSpecBA[$element][$species] =
                   sqrt($accumSpecBondAngle[$element][$species] /
                   $numTotalSpecBondAngles[$element][$species]);}
      }
   }

   # Do the same thing for each atom.
   foreach $atom (1..$numAtoms)
   {
      # Ensure that we do not divide by zero when computing the average bond
      #   length for this atom.
      if ($numTotalAtomBonds[$atom] == 0)
         {&atomWarning($atom,1);}
      else
         {$stdAtomBL[$atom] =
               sqrt($accumAtomBondLength[$atom] / $numTotalAtomBonds[$atom]);}

      # Ensure that we do not divide by zero when computing the average bond
      #   angle for this atom.
      if ($numTotalAtomBondAngles[$atom] == 0)
         {&atomWarning($atom,2);}
      else
         {$stdAtomBA[$atom] = sqrt($accumAtomBondAngle[$atom] /
               $numTotalAtomBondAngles[$atom]);}
   }
}

sub setBoxBorder
{
   # Define local variables.
   my $axis;

   # For any end points given as "max" values, we must fill them here
   #   depending on which type of coordinates we are using.
   foreach $axis (1..3)
   {
      if ($boxBorders[$axis][2] eq "max")
      {
         if ($coordType == 1) # Direct space xyz for orthorhombic cells only.
            {$boxBorders[$axis][2] = $mag_ref->[$axis];}
         elsif ($coordType == 2) # Direct space abc.
            {$boxBorders[$axis][2] = $mag_ref->[$axis];}
         else # Fractional abc.
            {$boxBorders[$axis][2] = 1.0;}
      }
   }

   # Set the border so that we include only the requested atoms.
   StructureControl::setBorder($zone,$coordType,$boxBorders[1][1],
         $boxBorders[2][1],$boxBorders[3][1],$boxBorders[1][2],
         $boxBorders[2][2],$boxBorders[3][2]);
}

sub elementWarning
{
   # Define local variables.
   my $element;
   my $warnType;
   my $warning;

   # Define passed parameters.
   $element  = $_[0];
   $warnType = $_[1];

   if ($warnType == 1)
      {$warning = "Element $elementList_ref->[$element] has no bonds for" .
                  " bondingFactor = $bondingFactor\n";}
   else
      {$warning = "Element $elementList_ref->[$element] has no bond angles" .
                  " for bondFactor = $bondingFactor\n";}

   print STDOUT $warning;
}

sub speciesWarning
{
   # Define local variables.
   my $element;
   my $species;
   my $warnType;
   my $warning;

   # Define passed parameters.
   $element  = $_[0];
   $species  = $_[1];
   $warnType = $_[2];

   if ($warnType == 1)
      {$warning = "Species $speciesList_ref->[$element][$species]".
                  " has no bonds for bondFactor = $bondingFactor\n";}
   else
      {$warning = "Species $speciesList_ref->[$element][$species]".
                  " has no bond angles for bondFactor = $bondingFactor\n";}

   print STDOUT $warning;
}

sub atomWarning
{
   # Define local variables.
   my $atom;
   my $warnType;
   my $warning;

   # Define passed parameters.
   $atom = $_[0];
   $warnType = $_[1];

   if ($warnType == 1)
      {$warning = "Atom $atom has no bonds for bondFactor = $bondingFactor\n";}
   elsif ($warnType == 2)
      {$warning = "Atom $atom has no bond angles for bondFactor".
                  " = $bondingFactor\n";}

   print STDOUT $warning;
}

#sub printFragments
#{
#   # Declare local variables.
#   my $frag;
#   my $currFragAtom;
#   my $fragFileName;
#
#   # Pull in useful information from StructureControl.
#   $numFragments = StructureControl::getNumFragments();
#   $fragNumBonds_ref = StructureControl::getFragNumBonds();
#   $fragNumAngles_ref = StructureControl::getFragNumAngles();
#   $fragNumAtoms_ref = StructureControl::getFragNumAtomsRef()
#   $fragKeepAtom_ref = StructureControl::getFragKeepAtomRef();
#   $fragNumEdgeIDs_ref = StructureControl::getFragNumEdgeIDsRef();
#   $fragEdgeID_ref = StructureControl::getFragEdgeIDRef();
#
#   foreach $frag (1..$numFragments)
#   {
#      # Define the name of the data file for this fragment.
#      $fragFileName = $outFile . "_$fragmentTagList[$frag].frag";
#
#      # Open a data file for this specific fragment.
#      open (FRAG,">$fragFileName")
#            || die "Cannot open $fragFileName for writing\n";
#
#      # Print the information that will be needed to create bond-react
#      #   templates for LAMMPS. Specifically, this is:
#      #   (1) The number of atoms in the fragment.
#      #   (2) The element-species tag for each atom.
#      #   (3) The number of bonds in the fragment.
#      #   (4) For each atom, a list of which atoms it is bonded to.
#      #   (5) The number of angles in the fragment.
#      #   (6) For each atom, a list of which bond angles it is central to.
#
#      # Record the number of atoms in this fragment and then print the
#      #   element-species tag for each.
#      print FRAG "NumAtoms = $fragNumAtoms_ref->[$frag]\n";
#
#      # Consider all atoms in the current molecule but only print information
#      #   for the atoms that are kept in this fragment.
#      $currFragAtom = 0;
#      foreach $atom (1..$numAtoms)
#      {
#         # Don't print anything for atoms that are not kept.
#         if ($fragKeepAtom_ref->[$frag][$atom] == 0)
#            {next;}
#         else
#            {$currFragAtom++;}
#
#         # Print the atom index number in this fragment, the element name, the
#         #   element ID number, and the species ID number.
#         print FRAG "$currFragAtom $atomElementName_ref->[$atom] " .
#               "$atomElementID_ref->[$atom] $atomSpeciesID_ref->[$atom]\n";
#      }
#
#      # Record the number and nature of the bonds in this fragment.
#      #   the bonds.
#      print FRAG "NumBonds = $fragNumBonds_ref->[$frag]\n";
#
#      # Print the bond list.
#      foreach $bond (1..$fragNumBonds_ref->[$frag])
#      {print FRAG "\n";}
#
#      # Record the number and nature of the bond angles in this fragment.
#      print FRAG "NumBondAngles = $fragNumAngles_ref->[$frag]\n";
#
#      # Print the bond angle list.
#      foreach $angle (1..$fragNumAngles_ref->[$frag])
#      {
#         print FRAG "\n";
#      }
#
#      # Close this data file.
#      close (FRAG);
#   }
#}
