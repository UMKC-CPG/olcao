#!/usr/bin/env perl

sub printHelp
{
   print <<ENDHELP;
# PROGRAM: condense
# PURPOSE: To create all the necessary input files for running a LAMMPS
#          condensation on a set of molecules with defined reaction types.
# INPUT:
# Expected input: Keywords that define sections. Sections follow the Keywords.
# The Keywords may have an accompanying Value that defines the number of lines
#   in the rest of the section. The Keywords and their sections are defined as
#   follows:
#
#   (1) Composition:
#   Keyword: "composition";
#   Required Value: Following the word "composition" is an integer that
#      signifies the number of different types of molecules that will be used
#      in the simulation. Each type of molecule must be present in the
#      precursor database.
#   Section Definition: One line for each type of molecule. Each line contains
#      a molecule name followed by a family name followed by an integer.
#      IMPORTANT NOTE: The lines MUST be alphabetized by <MOLECULENAME>.
#   Molecule Name: A molecule name is specified in two parts and referred to in
#      total with <MOLECULENAME>. The parts of <MOLECULENAME> are separated by
#      a "_" and are given by (1) The chemical formula; and (2) an integer that
#      signifies a particular type assignment for atoms in that molecule and/or
#      different possible conformations or atomic arrangements for the same
#      chemical formula. In general, the precursor database is expected to
#      contain a directory called <MOLECULENAME>. Inside that directory *at a
#      minimum* is a file with the name <MOLECULENAME>.skl. So, for a specific
#      example, if <MOLECULENAME> is "h2o_1" then the precursor database should
#      have a "h2o_1/" directory with a file in it with the name "h2o_1.skl".
#   Family Name: A family name is any simple string. All molecules with the
#      same family name will share the same element-species types. For example,
#      if molecules ch4 and c2h6 both have the same family name, then a c1 from
#      ch4 and a c1 from c2h6 will *not* be recognized as different types in
#      LAMMPS. On the other hand, if they have different family names, then
#      the two c1 atoms *will be* recognized as different types. If you want
#      a molecule to not be a part of a broader family then just make the
#      molecule name and the family name equal to each other.
#   Integer: The <MOLECULENAME> part of the line must be followed by an integer
#      that indicates how many of that type of molecule should be placed in the
#      simulation box.
#   NOTE on <MOLECULENAME>: the integer part of the <MOLECULENAME> is used to
#      distinguish different possible type assignments for atoms in the
#      molecule so that, for example, in a simplified simulation all of the
#      atoms could have type = 1. Or, if the molecule was somewhat complicated,
#      different atoms of the same element could be given different types to
#      distinguish their different electronic environments. An example would be
#      b10c2h12. This icosahedral molecule will have different types of B atoms
#      because some will have C neighbors and some will not. As another
#      complicated example using b10c2h12, the positions of the 2 C atoms in
#      the icosahedra can vary with three different possible options: (1) para;
#      (2) meta; and (3) ortho. Each of those molecules can be specified using
#      a different integer number as part of the <MOLECULENAME>.
#
#   (2) Cell:
#   Keyword: "cell_size";
#   Required Value: Floating point size of the cell in Angstroms;
#   Section Definition: Absent. No section information needed.
#
#   (3) Reactions:
#   Keyword: "reactions";
#   Required Value: Integer number of different kinds of reactions.
#   Section Definition: One line with 5 components for each type of reaction.
#      Each line contains a pair of <MOLECULENAME> + element-type designations
#      followed by a real number between 0.0 and 1.0 inclusive. The
#      <MOLECULENAME> values must be consistent with those specified in the
#      "Components" section and the element-type values must be elements and
#      types that are present in the given molecules. The real number is the
#      probability that the reaction will occur once the molecular fragments
#      are sufficiently close. So, for example a reaction leading with some
#      probability (say 0.86) to the binding of two ch4 molecules would be
#      expressed on one line as: "ch4_1 c-1 ch4_1 c-1 0.86".
#   NOTE: The working expectation in all cases is that every reaction will
#      require that an H atom is is discharged from each molecule before the
#      binding between the requested underlying atoms can take place.

# Example input:
# 
# composition 3
# b10c2h12 Family2 30
# c2h6 Family1 3
# ch4 Family1 8
#
# cell_size 100.0
#
# reactions 6
# b10c2h12 b-1 b10c2h12 b-1 0.85
# b10c2h12 b-1 ch4 c-1 0.85
# b10c2h12 b-1 c2h6 c-1 0.75
# ch4 c-1 ch4 c-1 0.5
# ch4 c-1 c2h6 c-1 0.7
# c2h6 c1 c2h6 c-1 0.8


# Prepare molecules and reactions.
#
# The above input file is read and, if the precursor database does not already
#   contain the desired information, the "makeReactions" script is executed for
#   each of the molecule reaction pairs. The makeReactions script produces a
#   number of output files for each pair. The most important are the preRxn and
#   postRxn molecule template files that will be used to drive the molecule
#   binding process. 


# Run Packmol
#
# The skeleton files associated with the molecules listed in the condense input
#   file will be grabbed, converted to PBD format (if the PDB is not already
#   present) and sent as input to the packmol program.


# Prepare LAMMPS input
#
#   The output PDB from packmol that includes all the molecules will be
#   converted into a skeleton file and then into a LAMMPS data file. At the
#   same time, the reaction templates will be gathered and compared to the
#   LAMMPS data file to ensure consistency for all bond types and bond-angle
#   types across all files. The results of that analysis will be used to
#   construct a LAMMPS "in" file. A slurm submission file is also created.

# The -i option is used to specify the name of the input file. If this option
#   is not given then the default value of "condense.in" will be used.
# The -help option gives this help.
#
# USAGE: condense [-i \$inputFile] | [-help]

ENDHELP
   exit;
}


###############################################
# Begin program execution #####################
###############################################

# Use necessary modules.
use strict;
use warnings;
use POSIX qw(ceil floor);
use Env;
use lib "$OLCAO_BIN/perl5";
use StructureControl;
use ElementData;
use BondData;
use AngleData;
use File::Copy;

# Declare global variables.
my $inputFile;
my $cellSize;
my $numMoleculeTypes;
my $numReactionTypes;
my $numUniqueRxnMolPairs;
my $rxnTemplateDir;
my @moleculeName;
my @numMolecules;
my %molecule2FamilyMap;
my @familyName;
my @numMolAtoms;
my @atomMoleculeID;
my @atomMoleculeName;
my @rxnMolName;
my @rxnBinding;
my @rxnProbability;
my $numHookeBonds;
my $numHookeAngles;
my $hookeBondCoeffs_ref;
my $hookeAngleCoeffs_ref;
my $numPeriodicElements; # Number of elements from periodic table database
my $elementNames_ref;
my $atomicMasses_ref;
my $ljPairCoeffs_ref;
my $precursorDB = "$OLCAO_DATA/precursorDB";

# Initialize the environment.
&initEnv;

# Read the command line parameters.
&parseCommandLine;

# Read the main input file.
&parseInputFile;

# Compute implicit information not explictly given in the input file.
&computeImplicitInput;

# Obtain the reaction templates from the database.
&copyReactionTemplates;

# Assemble the packmol input file and run packmol.
&runPackmol;
print STDOUT "Got Here1\n";

# Create LAMMPS data_file, LAMMPS in_file, and the slurm submission file.
&createLAMMPSFiles;
print STDOUT "Got Here2\n";

# Make all types and bond types consistent across all files.
&normalizeTypes;
print STDOUT "Got Here3\n";

###############################################
# End program execution #######################
###############################################

sub initEnv
{
   $inputFile = "condense.in";
   $rxnTemplateDir = "reactionTemplates";

   # Initialize the element database.
   ElementData::initElementData;
   $numPeriodicElements = ElementData::getNumElements;
   $elementNames_ref = ElementData::getElementNamesRef;
   $atomicMasses_ref = ElementData::getAtomicMassesRef;
   $ljPairCoeffs_ref = ElementData::getLJPairCoeffs;

   # Read the angle database.
   AngleData::initAngleData;
   $hookeAngleCoeffs_ref = AngleData::getHookeAngleCoeffsRef;
   $numHookeAngles = AngleData::getNumHookeAngles;

   # Read the bond database.
   BondData::initBondData;
   $hookeBondCoeffs_ref = BondData::getHookeBondCoeffsRef;
   $numHookeBonds = BondData::getNumHookeBonds;
}

sub parseCommandLine
{
   # Declare local variables
   my $number;
   my $argument;
   my $commandLine = "command";

   # Initialize the index counter for the command line parameters.
   $number=0;

   # Loop through the command line parameters checking for each option.
   while ($number < scalar(@ARGV))
   {
      if ($ARGV[$number] eq "-help")
         {&printHelp;}
      elsif ($ARGV[$number] eq "-i")
         {$inputFile = $ARGV[++$number];}
      else
      {
         print STDOUT "UNKNOWN COMMAND LINE PARAMETER $ARGV[$number].";
         print STDOUT " ABORTING.\n";
         exit;
      }
      $number++;
   }

   #Record the command line used to create this set of input files.
   open (COMMANDLINE,">>$commandLine");
   print COMMANDLINE "condense ";
   foreach $argument (0..$#ARGV)
      {print COMMANDLINE "$ARGV[$argument] ";}
   print COMMANDLINE "\n";
   close (COMMANDLINE);
}

sub parseInputFile
{
   # Define local variables.
   my $line;
   my @values;
   my $mol;
   my $rxn;

   # Open the condensation input file.
   open (INFILE,"<$inputFile") || die "Cannot open $inputFile for reading.\n";

   # Read the input file.
   while ($line = <INFILE>)
   {
      @values = StructureControl::prepLine("",$line,'\s+');

      # Look for "composition", "cell_size", and "reactions" key words.
      if (lc($values[0]) eq "composition")
      {
         $numMoleculeTypes = $values[1];

         foreach $mol (1..$numMoleculeTypes)
         {
            @values = StructureControl::prepLine(\*INFILE,"",'\s+');
            $moleculeName[$mol] = lc($values[0]);
            $familyName[$mol] = lc($values[1]);
            $molecule2FamilyMap{$moleculeName[$mol]} = $familyName[$mol];
            $numMolecules[$mol] = $values[2];
         }
      }
      elsif (lc($values[0]) eq "cell_size")
         {$cellSize = $values[1];}
      elsif (lc($values[0]) eq "reactions")
      {
         # Get the number of different types of reactions.
         $numReactionTypes = $values[1];

         # Read the descriptor for each reaction that includes the name of each
         #   of the participating molecules and the type of binding that each
         #   molecule makes available for that reaction to occur.
         foreach $rxn (1..$numReactionTypes)
         {
            @values = StructureControl::prepLine(\*INFILE,"",'\s+');
            $rxnMolName[1][$rxn] = lc($values[0]);
            $rxnBinding[1][$rxn] = lc($values[1]);
            $rxnMolName[2][$rxn] = lc($values[2]);
            $rxnBinding[2][$rxn] = lc($values[3]);
            $rxnProbability[$rxn] = $values[4];
         }
      }
   }
}

sub computeImplicitInput
{
   my $mol;
   my $atom;
   my $line;
   my $found;
   my $molFile;
   my @values;
   my $repeatMol;
   my $atomCount;
   my $molCount;
   my $command;
   my $currNumAtoms;

   # Compute the number of atoms in each of the molecules.
   foreach $mol (1..$numMoleculeTypes)
   {
      $molFile = "$precursorDB/" . lc($moleculeName[$mol]) . "/" .
            lc($moleculeName[$mol]) . ".skl";
      open (SKL,"<$molFile") || die "Cannot open $molFile for reading\n";

      while ($line = <SKL>)
      {
         if (($line =~ /^cart/) || ($line =~ /^frac/))
         {
            @values = StructureControl::prepLine("",$line,'\s+');
            $currNumAtoms = $values[1];
            last;
         }
      }
      close (SKL);

      $numMolAtoms[$mol] = $currNumAtoms;
   }

   # Now, assign a molecule number to each atom in the whole model.
   $atomCount = 0;
   $molCount = 0;
   foreach $mol (1..$numMoleculeTypes)
   {
      foreach $repeatMol (1..$numMolecules[$mol])
      {
         $molCount++;
         foreach $atom (1..$numMolAtoms[$mol])
         {
            $atomCount++;
            $atomMoleculeID[$atomCount] = $molCount;
#            $atomMoleculeName[$atomCount] = $moleculeName[$mol];
            $atomMoleculeName[$atomCount] = $familyName[$mol];
         }
      }
   }
}

# A database (called the precursorDB) should already contain certain very
#   useful input files for the condensation process. Therefore, the desired
#   files can be copied from the database into the reaction templates
#   directory, the packmol directory, and the lammps directory. None of the
#   files should need to be generated "on the fly" for this specific run
#   of the condense script.
# The specific files that are needed can be divided into two groups: molecule
#   files and reaction files. The molecule files each refer to one single
#   molecule and the reaction files refer to an integrated pair of molecules.
# Molecule Files: A PDB format file of each molecule is needed to build the
#   input for the packmol program. An OLCAO-style skeleton file is not needed
#   explicitly, but it is expected to be present because it is used to generate
#   all other files.
# Reaction Files: For each pair of named molecules in a reaction a set of pre-
#   and post- reaction template files are needed. Similalry, a map file that
#   connects them is also needed. IMPORTANT NOTE! The reaction templates are
#   *NOT* exactly the same as the files that will be used by LAMMPS. The
#   difference is that the type assignments in the template files and the type
#   assignments in the LAMMPS input/data files may be (likely are) different.
#   The types from each of the reaction template pairs need to be assigned
#   in a uniform consistent way across all files. Hence the need for calling
#   the normalizeTypes subroutine, etc.
sub copyReactionTemplates
{
   # Define local variables.
   my $id;
   my $found;
   my $rxn;
   my $rxnPair;
   my $rxnBindingPair;
   my $rxnMolBindingPair;
   my $currRxnMolPair;


   # Initialize the number of unique reaction molecule pairs to zero.
   $numUniqueRxnMolPairs = 0;

   # Create a directory for the combined set of reaction templates if it does
   #   not already exist. (It might already exist if this condense script is
   #   being called as a part of an iterative refinement process.)
   if (! -d "$rxnTemplateDir")
      {mkdir ("$rxnTemplateDir");}
   chdir ("$rxnTemplateDir");

   # For each reaction, copy the reaction templates and map files from the
   #   precursor database.
print STDOUT "numReactionTypes $numReactionTypes\n";
   foreach $rxn (1..$numReactionTypes)
   {
      # Construct the name for the current reaction molecule pair ensuring
      #   that the name will be uniquely ordered.
      if ($rxnMolName[1][$rxn] lt $rxnMolName[2][$rxn])
         {$currRxnMolPair = "$rxnMolName[1][$rxn]__$rxnMolName[2][$rxn]";}
      else
         {$currRxnMolPair = "$rxnMolName[2][$rxn]__$rxnMolName[1][$rxn]";}

      # Check that the currMolRxnPair actually exists in the database.
      if (! -d "$precursorDB/$currRxnMolPair")
         {die "Unable to find $precursorDB/$currRxnMolPair.\n";}

      # For the current reaction, grab the appropriate reaction templates
      #   and store them in the collective $rxnTemplatesDir directory with
      #   appropriate names to distinguish them.
print STDOUT "rxnBinding[1][$rxn] $rxnBinding[1][$rxn]\n";
print STDOUT "rxnBinding[2][$rxn] $rxnBinding[2][$rxn]\n";
print STDOUT "rxnMolName[1][$rxn] $rxnMolName[2][$rxn]\n";
      $rxnBindingPair = $rxnBinding[1][$rxn] . "_" . $rxnBinding[2][$rxn];
      $rxnMolBindingPair = $rxnMolName[1][$rxn] ."_". $rxnBinding[1][$rxn] .
         "_" . $rxnMolName[2][$rxn] . "_" . $rxnBinding[2][$rxn];

      # Copy all the pre- and post- template files.
print STDOUT "$precursorDB/$currRxnMolPair/rxnTemplates/preRxn.$rxnBindingPair.data\n";
print STDOUT "$precursorDB/$currRxnMolPair/rxnTemplates/postRxn.$rxnBindingPair.data\n";
      copy("$precursorDB/$currRxnMolPair/rxnTemplates/preRxn." .
         "$rxnBindingPair.data","preRxn.$rxnMolBindingPair.data");
      copy("$precursorDB/$currRxnMolPair/rxnTemplates/postRxn." .
         "$rxnBindingPair.data","postRxn.$rxnMolBindingPair.data");

      # Copy the map files.
      copy("$precursorDB/$currRxnMolPair/rxnTemplates/$rxnBindingPair.map",
         "$rxnMolBindingPair.map");
   }

   chdir ("..");
}

sub runPackmol
{
   # Define local variables.
   my $mol;
   my $rxn;
   my $line;
   my @values;
   my $molFile;
   my $randSeed;
   my $packmolFile;

   # Create a directory to run packmol in.
   mkdir ("packmol");
   chdir ("packmol");

   # Define the packmol input file.
   $packmolFile = "packmol.in";

   # Open the packmol input file that is to be written.
   open (PACK,">$packmolFile") || die "Cannot open $packmolFile for writing\n";

   # Add header comments.
   print PACK "#Packmol input file from condense.\n\n";

   # Insert the random seed and tolerance.
   $randSeed = int(rand(99999));
   print PACK "seed $randSeed\n";
   print PACK "tolerance 5.0\n";

   # The input and output file types for the molecules are PDB.
   print PACK "filetype pdb\n";
   print PACK "output packmol.raw.pdb\n\n";

   foreach $mol (1..$numMoleculeTypes)
   {
      # Do not put a molecule into the packmol input file if there are zero
      #   of them requested. This might occur if a molecule can be *assembled*
      #   from other components, but should not be present in the initial
      #   system.
      if ($numMolecules[$mol] == 0)
         {next;}

      print PACK "structure $moleculeName[$mol].pdb\n";
      print PACK "  number $numMolecules[$mol]\n";
      print PACK "  inside cube 0.0 0.0 0.0 $cellSize\n";
      print PACK "end structure\n\n";
   }

   # Close the packmol input file.
   close (PACK);

   # Copy in the necessary pdb files.
   foreach $mol (1..$numMoleculeTypes)
   {
      # As above, we may have certain molecules that are not present in the
      #   initial structure but which can be made during the lammps
      #   condensation process itself.
      if ($numMolecules[$mol] == 0)
         {next;}

      $molFile = "$precursorDB/" . lc($moleculeName[$mol]) . "/" .
            lc($moleculeName[$mol]) . ".pdb";
      copy("$molFile",".");
   }

   # Execute packmol. There are lots of options for this program. It may be
   #   necessary to enforce a distance between molecules so that no inter-
   #   molecular "bonds" or "bond angles" are defined between the molecules
   #   before the simulation starts.
   system("packmol < $packmolFile");

   # Unfortunately, the packmol program seems to not follow the PDB standard
   #   as specified here: http://www.wwpdb.org/documentation/file-format.
   #   Therefore, we will now correct the PDB file that was output by packmol.
   open (RAW,"<packmol.raw.pdb") ||
      die "Cannot open packmol.raw.pdb for reading.\n";
   open (FIXED,">packmol.fixed.pdb") ||
      die "Cannot open packmol.fixed.pdb for writing.\n";

   while ($line = <RAW>)
   {
      @values = StructureControl::prepLine("",$line,'\s+');
      if ($values[0] eq "ATOM")
      {
         print FIXED substr($line,0,54);
         print FIXED "  1.00  0.00";
         printf FIXED "%13s", $values[$#values];
         print FIXED "\n";
      }
      else
         {print FIXED "$line";}
   }

   close (RAW);
   close (FIXED);

   # Return to the main directory.
   chdir ("..");
}

sub createLAMMPSFiles
{
   # Define local variables.
   my @values;
   my @values2;
   my $found;
   my $axis;
   my $tag;
   my $mol;
   my $molType;
   my $atom;
   my $bond;
   my $bondCount;
   my $uniqueBond;
   my $hookeBond;
   my $angle;
   my $angleCount;
   my $uniqueAngle;
   my $hookeAngle;
   my $currentBondAngle;
   my $element;
   my $periodicElement;
   my $species;
   my $numAtoms;
   my $numElements;
   my $atomicZ_ref;
   my $atom1Z;
   my $atom2Z;
   my $atom3Z;
   my $atomElementName_ref;
   my $atomElementID_ref;
   my $atomSpeciesID_ref;
   my $numOrderedSpecies;
   my @orderedSpeciesTag;
   my @orderedSpeciesID;
   my @orderedSpeciesMasses;
   my @orderedSpeciesPairCoeffs;
   my @orderedBondType;
   my @orderedBondTypeCoeffs;
   my @orderedAngleType;
   my @orderedAngleTypeCoeffs;
   my @orderedBondedAtoms;
   my @angleBondedAtoms;
   my $numSpecies_ref;
   my $atomTag;
   my $numUniqueAtomTags;
   my @uniqueAtomTags;
   my $currentTag;
   my $tagPart1;
   my $tagPart2; # Vertex for angles.
   my $tagPart3;
   my $currentMol;
   my $numBondsTotal;
   my $numBonds_ref;
   my $bonded_ref;
   my $bondLength_ref;
   my $bondTagID_ref;
   my @bondTagID;
   my $numUniqueBondTags;
   my @uniqueBondCoeffs;
   my $uniqueBondTags_ref;
   my @uniqueBondTags;
   my $numBondAngles_ref;
   my $angleBonded_ref;
   my $angleTagID_ref;
   my @angleTagID;
   my $bondAnglesExt_ref;
   my $numUniqueAngleTags;
   my @uniqueAngleCoeffs;
   my $uniqueAngleTags_ref;
   my @uniqueAngleTags;
   my $numAnglesTotal;
   my $directXYZ_ref;
   my $maxVelocity;
   my @randVel;
   my $randSeed;
   my $randProb;
   my $numReactionMols;
   my @reactionMols;
   my $rxn;
   my $molFileFrom;
   my $mapFileDir;
   my $mapFileFrom;
   my $mapFileTo;

   # Create a directory for the LAMMPS data files and enter it.
   mkdir ("lammps");
   chdir ("lammps");

   # Convert the packmol PDB into a skeleton file.
print STDOUT "Got here 2a\n";
   copy("../packmol/packmol.fixed.pdb","./");
print STDOUT "Got here 2b\n";
   system("pdb2skl -i packmol.fixed.pdb -o packmol.skl -pdbtypes");
print STDOUT "Got here 2c\n";

   # Read the skeleton file and extract necessary information.
   StructureControl::readInputFile("packmol.skl",1);
   $numAtoms = StructureControl::getNumAtoms;
   $directXYZ_ref = StructureControl::getDirectXYZRef;
   $atomElementName_ref = StructureControl::getAtomElementNameRef;
print STDOUT "$atomElementName_ref->[1]\n";
   $atomElementID_ref = StructureControl::getAtomElementIDRef;
   $atomSpeciesID_ref = StructureControl::getAtomSpeciesIDRef;
   $atomicZ_ref = StructureControl::getAtomicZRef;
   $numElements = StructureControl::getNumElements;
   $numSpecies_ref = StructureControl::getNumSpeciesRef;
print STDOUT "Got here 2d\n";

   # Perform a bond analysis to get bond length and bond angle information.
   system("bondAnalysis -bl -bf 1.1 -i packmol.skl");
print STDOUT "Got here 2e\n";
   system("bondAnalysis -ba -bf 1.1 -i packmol.skl");
print STDOUT "Got here 2f\n";

   # Read the bondAnalysis results and extract necessary information.
   StructureControl::readBondAnalysisBL("bondAnalysis.bl",$numAtoms);
   StructureControl::readBondAnalysisBA("bondAnalysis.ba",$numAtoms);
   $bonded_ref = StructureControl::getBondingListRef;
   $bondLength_ref = StructureControl::getBondLengthExtRef;
   $bondTagID_ref = StructureControl::getBondTagIDRef;
   $uniqueBondTags_ref = StructureControl::getUniqueBondTagsRef;
   $numUniqueBondTags = StructureControl::getNumUniqueBondTags;
   $numBondAngles_ref = StructureControl::getNumBondAnglesRef;
   $angleBonded_ref = StructureControl::getAngleBondedRef;
   $angleTagID_ref = StructureControl::getAngleTagIDRef;
   $numUniqueAngleTags = StructureControl::getNumUniqueAngleTags;
   $uniqueAngleTags_ref = StructureControl::getUniqueAngleTagsRef;
   $bondAnglesExt_ref = StructureControl::getBondAngleExtRef;
   $numBondsTotal = StructureControl::getNumBondsTotal;
   $numAnglesTotal = StructureControl::getNumAnglesTotal;
   $numBonds_ref = StructureControl::getNumBondsRef;

   # Assign an *ordered* species number to each atom that is computed according
   #   to the element, species number, and molecule to which the atom belongs.
   #   Note that this is not a species number that is nested within the element
   #   ID number. For example, if a system has one type of molecule that
   #   contains 3 Si species and 2 O species and 90 atoms then the
   #   orderedSpeciesID for each of the 90 atoms will be a number between 1 and
   #   5 inclusive. As another example consider a system that contains H2O and
   #   CO2. The O from H2O and the O from CO2 will need to be identified as
   #   different species.
   $numOrderedSpecies = 0;
   $numUniqueAtomTags = 0;
   foreach $atom (1..$numAtoms)
   {
      # Assemble an element-species-molecule tag for this atom.
      $atomTag = "$atomElementName_ref->[$atom] $atomSpeciesID_ref->[$atom] ".
            "$atomMoleculeName[$atom]";

      # Determine if this atom tag has been seen before.
      $found = 0;
      foreach $tag (1..$numUniqueAtomTags)
      {
         if ($atomTag eq $uniqueAtomTags[$tag])
            {$found = $tag; last;}
      }

      if ($found == 0)
      {
         $numUniqueAtomTags++;
         $uniqueAtomTags[$numUniqueAtomTags] = $atomTag;
         $orderedSpeciesID[$atom] = $numUniqueAtomTags;
      }
      else
         {$orderedSpeciesID[$atom] = $found;}
   }
   $numOrderedSpecies = $numUniqueAtomTags;

   # Establish a unique list of the ordered species and important species info.
   $bondCount = 0;
   $angleCount = 0;
   $numUniqueBondTags = 0;
   $numUniqueAngleTags = 0;
   foreach $atom (1..$numAtoms)
   {
      foreach $species (1..$numOrderedSpecies)
      {
         if ($orderedSpeciesID[$atom] == $species)
         {
            # Assemble an element-species-molecule tag for this species.
            $orderedSpeciesTag[$species] =
               "$atomElementName_ref->[$atom] $atomSpeciesID_ref->[$atom] " .
               "$atomMoleculeName[$atom]";

            # Get the mass of each type of atom.
            $orderedSpeciesMasses[$species] =
               $atomicMasses_ref->[$atomicZ_ref->[$atom]];

            # Get the LJ pair coeffs for each type of atom. This is the first
            #   coeff, the second is recorded next. Note that the true LJ
            #   interaction is computed from the combination of coefficients
            #   from different elements.
            $orderedSpeciesPairCoeffs[$species][1] =
               $ljPairCoeffs_ref->[$atomicZ_ref->[$atom]][1];

            $orderedSpeciesPairCoeffs[$species][2] =
               $ljPairCoeffs_ref->[$atomicZ_ref->[$atom]][2];

            # Quit now that we found it.
            last;
         }
      }

      foreach $bond (1..$numBonds_ref->[$atom])
      {
         # Determine if this bond has been counted already. If so, then skip to
         #   the next bond. We only count each bond once.
         if ($atom > $bonded_ref->[$atom][$bond])
            {next;}

         # Increment a count of all bonds.
         $bondCount++;

         # Create a unique element-species-molecule tag for this bond.
         $tagPart1 = "$atomElementName_ref->[$atom] ".
               "$atomSpeciesID_ref->[$atom] $atomMoleculeName[$atom]";
         $tagPart2 = "$atomElementName_ref->[$bonded_ref->[$atom][$bond]] ".
               "$atomSpeciesID_ref->[$bonded_ref->[$atom][$bond]] ".
               "$atomMoleculeName[$bonded_ref->[$atom][$bond]]";
         if ("$tagPart1" lt "$tagPart2")
            {$currentTag = "$tagPart1 $tagPart2";}
         else
            {$currentTag = "$tagPart2 $tagPart1";}

         # Determine if this tag is a unique one.
         $found = 0;
         foreach $tag (1..$numUniqueBondTags)
         {
            if ($currentTag eq $uniqueBondTags[$tag])
               {$found = $tag; last;}
         }

         if ($found == 0)
         {
            $uniqueBondTags[++$numUniqueBondTags] = $currentTag;
            $found = $numUniqueBondTags;
         }

         $bondTagID[$atom][$bond] = $found;

         # Get the current tag for this bond and then extract the atomic
         #   Z numbers for both the $atom and the atom bonded to $atom.
         @values = StructureControl::prepLine("",$currentTag,'\s+');

         # Extract the Z numbers by search because the tag was alphabetized so
         #   that there is no guarentee that the first part of the tag
         #   corresponds to $atom.
         $atom1Z = ElementData::getElementZ($values[0]);
         $atom2Z = ElementData::getElementZ($values[3]);

         # Make sure that $atom1Z < $atom2Z.
         if ($atom1Z > $atom2Z)
            {($atom1Z,$atom2Z) = ($atom2Z,$atom1Z);}

         # Record the bonded atoms and bond types in an ordered list.
         $orderedBondedAtoms[$bondCount][1] = $atom;
         $orderedBondedAtoms[$bondCount][2] = $bonded_ref->[$atom][$bond];
         $orderedBondType[$bondCount] = $bondTagID[$atom][$bond];

         # Collect the coefficients for each of the unique bond types.
         foreach $hookeBond (1..$numHookeBonds)
         {
            # This should be possible if the bonds.dat file always has the
            #   lower Z number atom listed first.
            if (($atom1Z == $hookeBondCoeffs_ref->[$hookeBond][1]) and
                ($atom2Z == $hookeBondCoeffs_ref->[$hookeBond][2]))
            {
               $uniqueBondCoeffs[$bondTagID[$atom][$bond]][1] =
                  $hookeBondCoeffs_ref->[$hookeBond][3];
               $uniqueBondCoeffs[$bondTagID[$atom][$bond]][2] =
                  $hookeBondCoeffs_ref->[$hookeBond][4];
            }
         }
      }

      foreach $angle (1..$numBondAngles_ref->[$atom])
      {
         # Note that bond angles were not double listed in the bondAnalysis.ba
         #   file (unlike the double listed bonds in bondAnalysis.bl). Thus, we
         #   don't need to check for double counted bond angles here.

         # Increment a count of all bond angles.
         $angleCount++;

         # Get the current tag for this bond angle and then extract the atomic
         #   Z numbers for the vertex atom and the non-vertex atoms.
print STDOUT "$atomElementName_ref->[$atom] $atomSpeciesID_ref->[$atom] $atomMoleculeName[$atom]\n";
         $tagPart2 = "$atomElementName_ref->[$atom] ".
               "$atomSpeciesID_ref->[$atom] $atomMoleculeName[$atom]";
         $tagPart1 =
               "$atomElementName_ref->[$angleBonded_ref->[$atom][$angle][1]] ".
               "$atomSpeciesID_ref->[$angleBonded_ref->[$atom][$angle][1]] ".
               "$atomMoleculeName[$angleBonded_ref->[$atom][$angle][1]]";
         $tagPart3 =
               "$atomElementName_ref->[$angleBonded_ref->[$atom][$angle][2]] ".
               "$atomSpeciesID_ref->[$angleBonded_ref->[$atom][$angle][2]] ".
               "$atomMoleculeName[$angleBonded_ref->[$atom][$angle][2]]";
         if ("$tagPart1" lt "$tagPart3")
            {$currentTag = "$tagPart1 $tagPart2 $tagPart3";}
         else
            {$currentTag = "$tagPart3 $tagPart2 $tagPart1";}

         # Extract the Z numbers by search. (Probably the middle part can be
         #   directly extracted because it should always correspond to $atom.
         @values = StructureControl::prepLine("",$currentTag,'\s+');
print STDOUT "$currentTag\n";
         $atom1Z = ElementData::getElementZ($values[0]);
         $atom2Z = ElementData::getElementZ($values[3]);
         $atom3Z = ElementData::getElementZ($values[6]);
print STDOUT "$atom1Z $atom2Z $atom3Z\n";

         # Make sure that $atom1Z < $atom3Z.
         if ($atom1Z > $atom3Z)
            {($atom1Z,$atom3Z) = ($atom3Z,$atom1Z);}

         # Find the angle in the database.
         $found = 0;
         foreach $hookeAngle (1..$numHookeAngles)
         {
            if (($atom1Z == $hookeAngleCoeffs_ref->[$hookeAngle][1]) and
                ($atom2Z == $hookeAngleCoeffs_ref->[$hookeAngle][2]) and
                ($atom3Z == $hookeAngleCoeffs_ref->[$hookeAngle][3]))
            {
               if (abs($bondAnglesExt_ref->[$atom][$angle]
                     - $hookeAngleCoeffs_ref->[$hookeAngle][5])
                     <= $hookeAngleCoeffs_ref->[$hookeAngle][6])
                  {$found = $hookeAngle; last;}
            }
         }
         if ($found == 0)
         {
            print STDOUT "Angle number = $angle ".
                  "Angle = $bondAnglesExt_ref->[$atom][$angle]\n";
            print STDOUT "atomZSet = $atom1Z $atom2Z $atom3Z\n";
                  die "Cannot find angle in the database\n";
         }
         else
            {$currentTag = "$currentTag $hookeAngleCoeffs_ref->[$found][5] ".
                     "$found";}

         # Determine if this tag is a unique one.
         $found = 0;
         foreach $tag (1..$numUniqueAngleTags)
         {
            if ($currentTag eq $uniqueAngleTags[$tag])
               {$found = $tag; last;}
         }

         if ($found == 0)
         {
            $uniqueAngleTags[++$numUniqueAngleTags] = $currentTag;
            $found = $numUniqueAngleTags;
         }
         $angleTagID[$atom][$angle] = $found;

         # Collect the coefficients for each of the unique bond angle types.
         foreach $hookeAngle (1..$numHookeAngles)
         {
            if ((($atom1Z == $hookeAngleCoeffs_ref->[$hookeAngle][1]) and
                 ($atom2Z == $hookeAngleCoeffs_ref->[$hookeAngle][2]) and
                 ($atom3Z == $hookeAngleCoeffs_ref->[$hookeAngle][3])) or
                (($atom3Z == $hookeAngleCoeffs_ref->[$hookeAngle][1]) and
                 ($atom2Z == $hookeAngleCoeffs_ref->[$hookeAngle][2]) and
                 ($atom1Z == $hookeAngleCoeffs_ref->[$hookeAngle][3])))
            {
               $uniqueAngleCoeffs[$angleTagID[$atom][$angle]][1] = 
                  $hookeAngleCoeffs_ref->[$hookeAngle][4];
               $uniqueAngleCoeffs[$angleTagID[$atom][$angle]][2] = 
                  $hookeAngleCoeffs_ref->[$hookeAngle][5];
            }
         }

         $angleBondedAtoms[$angleCount][1]=$angleBonded_ref->[$atom][$angle][1];
         $angleBondedAtoms[$angleCount][2]=$atom;
         $angleBondedAtoms[$angleCount][3]=$angleBonded_ref->[$atom][$angle][2];

         $orderedAngleType[$angleCount] = $angleTagID[$atom][$angle];
      }
   }

   # Open the LAMMPS data file for writing.
   open (LMPDAT,">lammps.dat") || die "Cannot open lammps.dat for writing.\n";

   # Print the header.
   print LMPDAT "lammps.dat\n\n";

   # Print number of items and number of types.
   print LMPDAT "$numAtoms atoms\n";
   print LMPDAT "$numBondsTotal bonds\n";
   print LMPDAT "$numAnglesTotal angles\n";
   print LMPDAT "0 dihedrals\n";
   print LMPDAT "0 impropers\n\n";
   print LMPDAT "$numOrderedSpecies atom types\n";
   print LMPDAT "$numUniqueBondTags bond types\n";
   print LMPDAT "$numUniqueAngleTags angle types\n\n";
#   print LMPDAT "1 extra bond per atom\n";
   print LMPDAT "0.000 $cellSize xlo xhi\n";
   print LMPDAT "0.000 $cellSize ylo yhi\n";
   print LMPDAT "0.000 $cellSize zlo zhi\n\n";

   # Print the Mass information for each atom type.
   print LMPDAT "Masses\n\n";
   foreach $species (1..$numOrderedSpecies)
   {
      print LMPDAT "$species $orderedSpeciesMasses[$species] ".
         "# $orderedSpeciesTag[$species]\n";
   }

   # Print out the pair coefficients for the LJ interaction of each bond type.
   print LMPDAT "\nPair Coeffs\n\n";
   foreach $species (1..$numOrderedSpecies)
   {
      print LMPDAT "$species $orderedSpeciesPairCoeffs[$species][1] " .
         "$orderedSpeciesPairCoeffs[$species][2] " .
         "# $orderedSpeciesTag[$species]\n";
   }

   # Print the bond coefficients for the spring-like interaction of each
   #   bond type.
   print LMPDAT "\nBond Coeffs\n\n";
   foreach $bond (1..$numUniqueBondTags)
   {
      print LMPDAT "$bond $uniqueBondCoeffs[$bond][1] " .
         "$uniqueBondCoeffs[$bond][2] " .
         "# $uniqueBondTags[$bond]\n";
   }

   # Print the bond angle coefficients for the spring-like interaction.
   print LMPDAT "\nAngle Coeffs\n\n";
   foreach $angle (1..$numUniqueAngleTags)
   {
      print LMPDAT "$angle $uniqueAngleCoeffs[$angle][1] " .
         "$uniqueAngleCoeffs[$angle][2] " .
         "# $uniqueAngleTags[$angle]\n";
   }

   # Print the atom information.
   print LMPDAT "\nAtoms\n\n";
   foreach $atom (1..$numAtoms)
   {
      print LMPDAT "$atom $atomMoleculeID[$atom] " .
         "$orderedSpeciesID[$atom] 0.00 ";
      foreach $axis (1..3)
         {print LMPDAT " $directXYZ_ref->[$atom][$axis]";}
      print LMPDAT " # $atomElementName_ref->[$atom] " .
         "$atomSpeciesID_ref->[$atom] $atomMoleculeName[$atom]\n";
   }

   # Print the initial velocities for the molecules.
   print LMPDAT "\nVelocities\n\n";
   $currentMol = 0;
   foreach $atom (1..$numAtoms)
   {
      # Create random velocities between +,- maxVelocity for each molecule.
      #   Note that the assumption is that all atoms of the same molecule
      #   appear next to each other in the list of atoms. Otherwise this does
      #   not work.
      $maxVelocity = 0.5;
      if ($atomMoleculeID[$atom] != $currentMol)
      {
         foreach $axis (1..3)
            {$randVel[$axis] = rand($maxVelocity*2)-$maxVelocity;}
         $currentMol = $atomMoleculeID[$atom];
      }
      print LMPDAT "$atom $randVel[1] $randVel[2] $randVel[3] ";
      print LMPDAT " # $atomElementName_ref->[$atom] " .
         "$atomSpeciesID_ref->[$atom] $atomMoleculeName[$atom]\n";
   }

   # Print the bond information.
   print LMPDAT "\nBonds\n\n";
   foreach $bond (1..$numBondsTotal)
   {
      print LMPDAT "$bond $orderedBondType[$bond] " .
         "$orderedBondedAtoms[$bond][1] $orderedBondedAtoms[$bond][2] # " .
         "$uniqueBondTags[$orderedBondType[$bond]]\n";
#         "$atomElementName_ref->[$orderedBondedAtoms[$bond][1]] " .
#         "$atomSpeciesID_ref->[$orderedBondedAtoms[$bond][1]] " .
#         "$atomMoleculeName[$orderedBondedAtoms[$bond][1]] " .
#         "$atomElementName_ref->[$orderedBondedAtoms[$bond][2]] " .
#         "$atomSpeciesID_ref->[$orderedBondedAtoms[$bond][2]] ".
#         "$atomMoleculeName[$orderedBondedAtoms[$bond][1]]\n";
   }

   # Print the bond angle information.
   print LMPDAT "\nAngles\n\n";
   foreach $angle (1..$numAnglesTotal)
   {
      print LMPDAT "$angle $orderedAngleType[$angle] " .
         "$angleBondedAtoms[$angle][1] $angleBondedAtoms[$angle][2] " .
         "$angleBondedAtoms[$angle][3] # " .
         "$uniqueAngleTags[$orderedAngleType[$angle]]\n";
#         "$atomElementName_ref->[$angleBondedAtoms[$angle][1]] ".
#         "$atomSpeciesID_ref->[$angleBondedAtoms[$angle][1]] " .
#         "$atomMoleculeName[$angleBondedAtoms[$angle][1]] " .
#         "$atomElementName_ref->[$angleBondedAtoms[$angle][2]] " .
#         "$atomSpeciesID_ref->[$angleBondedAtoms[$angle][2]] ".
#         "$atomMoleculeName[$angleBondedAtoms[$angle][2]] " .
#         "$atomElementName_ref->[$angleBondedAtoms[$angle][3]] ".
#         "$atomSpeciesID_ref->[$angleBondedAtoms[$angle][3]] ".
#         "$atomMoleculeName[$angleBondedAtoms[$angle][3]]\n";
#      if ($angle != $numAnglesTotal)
#         {print LMPDAT "\n";}
   }

   # Close the LAMMPS data file.
   close (LMPDAT);

   # Open the LAMMPS input file for writing.
   open (LMPIN,">lammps.in") || die "Cannot open lammps.in for writing.\n";

   # Fill the LAMMPS input file with appropriate header information.
   print LMPIN<<ENDLAMMPSHEAD;
# A lammps command file for condensing a periodic cell.

# Initialization

units real
dimension 3
boundary p p p
atom_style full
pair_style lj/cut 10.0
bond_style harmonic
angle_style harmonic
neigh_modify every 50 delay 0 check yes
#comm_modify mode single cutoff 20.0
pair_modify shift yes mix sixthpower
newton on

# Atom definition
read_data lammps.dat extra/bond/per/atom 25 extra/special/per/atom 25

special_bonds lj/coul 0 1 1

########################
# Initialization
########################

timestep 0.001

# Set up output

#restart 50000 restart.fast1.0 restart.fast1.1

dump coords all atom 500 dump.coarse
#dump_modify coords scale no

#compute bnd all property/local btype batom1 batom2
#dump bonds all local 500 dump.bond.coarse index c_bnd[1] c_bnd[2] c_bnd[3]

#compute ang all property/local atype aatom1 aatom2 aatom3
#dump angles all local 500 dump.angle.coarse index c_ang[1] c_ang[2] c_ang[3] c_ang[4]

# Initial minimization

#minimize 1.0e-15 1.0e-15 1000000 100000000
#minimize 1.0e-15 1.0e-15 1000 1000000

########################
# Coarse run
########################

region simcell block EDGE EDGE EDGE EDGE EDGE EDGE units box

ENDLAMMPSHEAD

   # Insert the molecule definitions. There will be eight for every reaction
   #   because there are four phases to a reaction and a pre and post aspect
   #   to each phase.
   print LMPIN "# Molecules\n";
   foreach $rxn (1..$numReactionTypes)
   {
      $molFileFrom = "preRxn.$rxnMolName[1][$rxn]"."_$rxnBinding[1][$rxn]" .
         "_$rxnMolName[2][$rxn]"."_$rxnBinding[2][$rxn].data";
      copy ("../reactionTemplates/$molFileFrom",".");
      print LMPIN "molecule MOLpre$rxn $molFileFrom\n";
      $molFileFrom = "postRxn.$rxnMolName[1][$rxn]"."_$rxnBinding[1][$rxn]".
         "_$rxnMolName[2][$rxn]"."_$rxnBinding[2][$rxn].data";
      copy ("../reactionTemplates/$molFileFrom",".");
      print LMPIN "molecule MOLpost$rxn $molFileFrom\n";
   }

   # Insert the bond reactions.
   print LMPIN "\n# Bond Reactions\n";
   print LMPIN "fix reaction all bond/react stabilization no &\n";
   foreach $rxn (1..$numReactionTypes)
   {
      # Prepare the map file and print the react command for each phase in the
      #   current reaction.
      $randSeed = int(rand(99999));
      $mapFileDir = "$rxnMolName[1][$rxn]" . "__$rxnMolName[2][$rxn]";
      $mapFileFrom = "$rxnBinding[1][$rxn]" . "_$rxnBinding[2][$rxn].map";
      $mapFileTo = "$rxnMolName[1][$rxn]"."_$rxnBinding[1][$rxn]".
         "_$rxnMolName[2][$rxn]"."_$rxnBinding[2][$rxn].map";
      copy ("../reactionTemplates/$mapFileTo", ".");
      print LMPIN "  react RXN$rxn all 100 0.0 2.0 MOLpre$rxn MOLpost$rxn " .
         "$mapFileTo prob $rxnProbability[$rxn] $randSeed";
      if ($rxn < $numReactionTypes)
         {print LMPIN " &\n";}
      else
         {print LMPIN "\n";}
   }

   # Fill the LAMMPS input file with appropriate tail information.
   print LMPIN<<ENDLAMMPSTAIL;

fix energy all nve
fix squish all deform 500 x scale 0.33 y scale 0.33 z scale 0.33 remap x

# Run

run 60000
unfix squish
run 100000
ENDLAMMPSTAIL

   # Close the LAMMPS input file.
   close (LMPIN);

   # Create the slurm file.
   open (SLURM, ">slurm") || die "Cannot open slurm for writing.\n";

   my $lmpDir = `pwd`;
   chomp $lmpDir;

   print SLURM<<ENDSLURM;
#!/bin/bash
#SBATCH -p Lewis
#SBATCH -J lmp
#SBATCH -o lmp.o%J
#SBATCH -e lmp.e%J
#SBATCH -N 1
#SBATCH -n 8
#SBATCH -t 00:15:00
#SBATCH --mem=2G
#
export OMP_NUM_THREADS=1
cd \$SLURM_SUBMIT_DIR
mpirun $HOME/bin/lmp_mpi_gcc4_intel2016 < lammps.in
ENDSLURM

   # Close the slurm file.
   close (SLURM);

   # Return to the project directory.
   chdir ("..");
}

# We need to open each molecule file and also the lammps data file and collect
#   information about all the bond types that are present. Those bond types
#   will be analyzed and assembled into a list of the unique bond types. Then
#   each file will be opened again and all the bond types will re-assigned
#   according to the unique list of *all* bond types.
sub normalizeTypes
{
   # Define the local variables.
   my $line;
   my $lineNum;
   my @values;
   my $bond;
   my $atom;
   my $angle;
   my $uniqueAtom;
   my $mol;
   my $bondTag;
   my $angleTag;
   my $uniqueBond;
   my $uniqueAngle;
   my @uniqueBondTypes;
   my @uniqueAngleTypes;
   my $numUniqueBonds;
   my $numUniqueAngles;
   my @uniqueBondCoeffs;
   my @uniqueAngleCoeffs;
   my @lammpsFile;
   my @molFiles;
   my @molFile;
   my $numMolFiles;
   my $numMolAtoms;
   my $numBonds;
   my $numAngles;
   my $numBondTypes;
   my $numAngleTypes;
   my $found;
   my $hookeBond;
   my $hookeAngle;
   my $atom1Z;
   my $atom2Z;
   my $atom3Z;
   my $bondType1;
   my $bondType2;
   my $angleType1;
   my $angleType2;
   my $angleType3;
   my $angleType4;
   my $atomType;
   my $numAtoms;
   my $numAtomTypes; # Number of LAMMPS atom types before reading mol files.
   my $numUniqueAtomTypes;
   my @uniqueAtomTypes;
   my @uniqueMasses;
   my @uniqueLJPairCoeffs;
   my $element;
   my $currBondAngle;

   # Enter the lammps directory to work.
   chdir ("lammps");

   # Initialize the number of unique bonds. Note that we do not initialize the
   #   number of unique atom types here because we have to count that number
   #   twice below (once for masses and once for pair coefficients).
   $numUniqueBonds = 0;
   $numUniqueAngles = 0;
   $numUniqueAtomTypes = 0;

   # Open the lammps data file and collect all the unique bond types.
   open (LMP,"<lammps.dat") || die "Cannot open lammps.dat for reading.\n";

   # Read the whole lammps.dat file into memory.
   @lammpsFile = <LMP>;
   chomp(@lammpsFile);
   close (LMP);

   # Parse the lammps.dat file.
   $lineNum = 0;
   while ($lineNum <= $#lammpsFile)
   {
      $line = $lammpsFile[$lineNum];
      if ($line =~ /atom types/)
      {
         @values = StructureControl::prepLine("",$line,'\s+');
         $numAtomTypes = $values[0];
      }
      elsif ($line =~ /bond types/)
      {
         @values = StructureControl::prepLine("",$line,'\s+');
         $numBondTypes = $values[0];
      }
      elsif ($line =~ /angle types/)
      {
         @values = StructureControl::prepLine("",$line,'\s+');
         $numAngleTypes = $values[0];
      }
      elsif ($line =~ /Masses/)
      {
         $lineNum++;
         foreach $atom (1..$numAtomTypes)
         {
            @values = StructureControl::prepLine("",
                  "$lammpsFile[++$lineNum]",'\s+');

            # Construct the atom type tag.
            $atomType = "$values[3] $values[4] $values[5]";

            # Determine if this atom type has been seen before.
            $found = 0;
            foreach $uniqueAtom (1..$numUniqueAtomTypes)
            {
               if ($uniqueAtomTypes[$uniqueAtom] eq $atomType)
                  {$found = $uniqueAtom; last;}
            }

            if ($found == 0)
            {
               $numUniqueAtomTypes++;
               $uniqueAtomTypes[$numUniqueAtomTypes] = $atomType;
            }
         }
      }
      elsif ($line =~ /Bond Coeffs/)
      {
         $lineNum++;
         foreach $bond (1..$numBondTypes)
         {
            @values = StructureControl::prepLine("",
                  "$lammpsFile[++$lineNum]",'\s+');

            $bondType1 = "$values[4] $values[5] $values[6]";
            $bondType2 = "$values[7] $values[8] $values[9]";

            # Determine if this bond has been seen before.
            $found = 0;
            foreach $uniqueBond (1..$numUniqueBonds)
            {
               if (($uniqueBondTypes[$uniqueBond][1] eq $bondType1) and
                   ($uniqueBondTypes[$uniqueBond][2] eq $bondType2))
                  {$found = $uniqueBond; last;}
            }

            if ($found == 0)
            {
               $numUniqueBonds++;
               $uniqueBondTypes[$numUniqueBonds][1] = $bondType1;
               $uniqueBondTypes[$numUniqueBonds][2] = $bondType2;
            }
         }
      }
      elsif ($line =~ /Angle Coeffs/)
      {
         $lineNum++;
         foreach $angle (1..$numAngleTypes)
         {
            @values = StructureControl::prepLine("",
                  "$lammpsFile[++$lineNum]",'\s+');
            $angleType1 = "$values[4] $values[5] $values[6]";
            $angleType2 = "$values[7] $values[8] $values[9]";
            $angleType3 = "$values[10] $values[11] $values[12]";
            $angleType4 = "$values[13] $values[14]";

            # Determine if this angle has been seen before.
            $found = 0;
            foreach $uniqueAngle (1..$numUniqueAngles)
            {
               if (($uniqueAngleTypes[$uniqueAngle][1] eq $angleType1) and
                   ($uniqueAngleTypes[$uniqueAngle][2] eq $angleType2) and
                   ($uniqueAngleTypes[$uniqueAngle][3] eq $angleType3) and
                   ($uniqueAngleTypes[$uniqueAngle][4] eq $angleType4))
                  {$found = $uniqueAngle; last;}
            }
   
            if ($found == 0)
            {
               $numUniqueAngles++;
               $uniqueAngleTypes[$numUniqueAngles][1] = $angleType1;
               $uniqueAngleTypes[$numUniqueAngles][2] = $angleType2;
               $uniqueAngleTypes[$numUniqueAngles][3] = $angleType3;
               $uniqueAngleTypes[$numUniqueAngles][4] = $angleType4;
            }
         }
      }
      $lineNum++;
   }

   # Get the molecule file names.
   @molFiles = `ls -1 preRxn*`;
   push(@molFiles,`ls -1 postRxn*`);
   chomp(@molFiles);
   $numMolFiles = unshift(@molFiles,"") - 1;

   # Open each molecule file and collect all the unique atom and bond types.
   foreach $mol (1..$numMolFiles)
   {
      open (MOL,"<$molFiles[$mol]") ||
         die "Cannot open $molFiles[$mol] for reading";

      while ($line = <MOL>)
      {
         if ($line =~ /atoms/)
         {
            @values = StructureControl::prepLine("",$line,'\s+');
            $numMolAtoms = $values[0];
         }
         elsif ($line =~ /bonds/)
         {
            @values = StructureControl::prepLine("",$line,'\s+');
            $numBonds = $values[0];
         }
         elsif ($line =~ /angles/)
         {
            @values = StructureControl::prepLine("",$line,'\s+');
            $numAngles = $values[0];
         }
         elsif ($line =~ /Types/)
         {
            <MOL>;
            foreach $atom (1..$numMolAtoms)
            {
               @values = StructureControl::prepLine(\*MOL,"",'\s+');

               # Adjust the molecule name to the family name.
               $values[5] = $molecule2FamilyMap{$values[5]};

               # Construct the atom type tag.
               $atomType = "$values[3] $values[4] $values[5]";

               # Determine if this atom type has been seen before.
               $found = 0;
               foreach $uniqueAtom (1..$numUniqueAtomTypes)
               {
                  if ($uniqueAtomTypes[$uniqueAtom] eq $atomType)
                     {$found = $uniqueAtom; last;}
               }

               if ($found == 0)
               {
                  $numUniqueAtomTypes++;
                  $uniqueAtomTypes[$numUniqueAtomTypes] = $atomType;
               }
            }
         }
         elsif ($line =~ /Bonds/)
         {
            <MOL>;
            foreach $bond (1..$numBonds)
            {
               @values = StructureControl::prepLine(\*MOL,"",'\s+');

               # Adjust the molecule names to the family names.
               $values[7] = $molecule2FamilyMap{$values[7]};
               $values[10] = $molecule2FamilyMap{$values[10]};

               # Construct the bond type tag.
               $bondType1 = "$values[5] $values[6] $values[7]";
               $bondType2 = "$values[8] $values[9] $values[10]";

               # Determine if this bond has been seen before.
               $found = 0;
               foreach $uniqueBond (1..$numUniqueBonds)
               {
                  if (("$uniqueBondTypes[$uniqueBond][1]" eq "$bondType1") and
                      ("$uniqueBondTypes[$uniqueBond][2]" eq "$bondType2"))
                     {$found = $uniqueBond; last;}
               }

               if ($found == 0)
               {
                  $numUniqueBonds++;
                  $uniqueBondTypes[$numUniqueBonds][1] = $bondType1;
                  $uniqueBondTypes[$numUniqueBonds][2] = $bondType2;
               }
            }
         }
         elsif ($line =~ /Angles/)
         {
            <MOL>;
            foreach $angle (1..$numAngles)
            {
               @values = StructureControl::prepLine(\*MOL,"",'\s+');

               # Adjust the molecule names to the family names.
               $values[8] = $molecule2FamilyMap{$values[8]};
               $values[11] = $molecule2FamilyMap{$values[11]};
               $values[14] = $molecule2FamilyMap{$values[14]};

               # Construct the angle type tag.
               $angleType1 = "$values[6] $values[7] $values[8]";
               $angleType2 = "$values[9] $values[10] $values[11]";
               $angleType3 = "$values[12] $values[13] $values[14]";
               $angleType4 = "$values[15] $values[16]";

               # Determine if this angle has been seen before.
               $found = 0;
               foreach $uniqueAngle (1..$numUniqueAngles)
               {
                  if (($uniqueAngleTypes[$uniqueAngle][1] eq $angleType1) and
                      ($uniqueAngleTypes[$uniqueAngle][2] eq $angleType2) and
                      ($uniqueAngleTypes[$uniqueAngle][3] eq $angleType3) and
                      ($uniqueAngleTypes[$uniqueAngle][4] eq $angleType4))
                     {$found = $uniqueAngle; last;}
               }
   
               if ($found == 0)
               {
                  $numUniqueAngles++;
                  $uniqueAngleTypes[$numUniqueAngles][1] = $angleType1;
                  $uniqueAngleTypes[$numUniqueAngles][2] = $angleType2;
                  $uniqueAngleTypes[$numUniqueAngles][3] = $angleType3;
                  $uniqueAngleTypes[$numUniqueAngles][4] = $angleType4;
               }
            }
         }
      }
      close (MOL);
   }


   # For each one of the unique bonds we need to get the bond coefficients.
   foreach $uniqueBond (1..$numUniqueBonds)
   {
      # Get the atomic Z numbers for this unique bond.
      @values = StructureControl::prepLine("",
         $uniqueBondTypes[$uniqueBond][1],'\s+');
      $atom1Z = ElementData::getElementZ($values[0]);
#      foreach $element (1..$numPeriodicElements)
#      {
#         if ("$values[0]" eq "$elementNames_ref->[$element]")
#            {$atom1Z = $element; last;}
#      }
      @values = StructureControl::prepLine("",
         $uniqueBondTypes[$uniqueBond][2],'\s+');
      $atom2Z = ElementData::getElementZ($values[0]);
#      foreach $element (1..$numPeriodicElements)
#      {
#         if ("$values[0]" eq "$elementNames_ref->[$element]")
#            {$atom2Z = $element; last;}
#      }

      # Make sure that $atom1Z < $atom2Z.
      if ($atom1Z > $atom2Z)
         {($atom1Z,$atom2Z) = ($atom2Z,$atom1Z);}

      foreach $hookeBond (1..$numHookeBonds)
      {
         if ((($atom1Z == $hookeBondCoeffs_ref->[$hookeBond][1]) and
              ($atom2Z == $hookeBondCoeffs_ref->[$hookeBond][2])) or
             (($atom2Z == $hookeBondCoeffs_ref->[$hookeBond][1]) and
              ($atom1Z == $hookeBondCoeffs_ref->[$hookeBond][2])))
         {
            $uniqueBondCoeffs[$uniqueBond][1] =
               $hookeBondCoeffs_ref->[$hookeBond][3];
            $uniqueBondCoeffs[$uniqueBond][2] =
               $hookeBondCoeffs_ref->[$hookeBond][4];
         }
      }
   }

   # For each one of the unique angle types we need to get the coefficients.
   foreach $uniqueAngle (1..$numUniqueAngles)
   {
      # Get the atomic Z numbers for this unique angle.
      @values = StructureControl::prepLine("",
         $uniqueAngleTypes[$uniqueAngle][1],'\s+');
      $atom1Z = ElementData::getElementZ($values[0]);

      @values = StructureControl::prepLine("",
         $uniqueAngleTypes[$uniqueAngle][2],'\s+');
      $atom2Z = ElementData::getElementZ($values[0]);

      @values = StructureControl::prepLine("",
         $uniqueAngleTypes[$uniqueAngle][3],'\s+');
      $atom3Z = ElementData::getElementZ($values[0]);

      # Make sure that atom1Z < atom3Z
      if ($atom1Z > $atom3Z)
         {($atom1Z,$atom3Z) = ($atom3Z,$atom1Z);}

      @values = StructureControl::prepLine("",
         $uniqueAngleTypes[$uniqueAngle][4],'\s+');
      $currBondAngle = $values[0];

      foreach $hookeAngle (1..$numHookeAngles)
      {
#print STDOUT "uniqueAnagle = $uniqueAngle   hookeAngle = $hookeAngle\n";
#print STDOUT "a1Z = $atom1Z  a2Z = $atom2Z  a3Z = $atom3Z\n";
#print STDOUT "hooke1 = $hookeAngleCoeffs_ref->[$hookeAngle][1] hooke2 = $hookeAngleCoeffs_ref->[$hookeAngle][2] hooke3 = $hookeAngleCoeffs_ref->[$hookeAngle][3]\n";
#print STDOUT "currBondAngle = $currBondAngle   hooke4 = $hookeAngleCoeffs_ref->[$hookeAngle][5]\n";
         if (($atom1Z == $hookeAngleCoeffs_ref->[$hookeAngle][1]) and
             ($atom2Z == $hookeAngleCoeffs_ref->[$hookeAngle][2]) and
             ($atom3Z == $hookeAngleCoeffs_ref->[$hookeAngle][3]) and
             (abs($currBondAngle - $hookeAngleCoeffs_ref->[$hookeAngle][5])
                <= $hookeAngleCoeffs_ref->[$hookeAngle][6]))
         {
            $uniqueAngleCoeffs[$uniqueAngle][1] =
                  $hookeAngleCoeffs_ref->[$hookeAngle][4];
            $uniqueAngleCoeffs[$uniqueAngle][2] =
                  $hookeAngleCoeffs_ref->[$hookeAngle][5];
            $uniqueAngleCoeffs[$uniqueAngle][3] = $hookeAngle;
         }
      }
   }

   # For each one of the unique atom types we need to get the pair coefficients
   #   and the masses.
   foreach $atomType (1..$numUniqueAtomTypes)
   {
      # Get the atomic Z number for this unique atom type.
      @values = StructureControl::prepLine("",$uniqueAtomTypes[$atomType],
            '\s+');
      $atom1Z = ElementData::getElementZ($values[0]);
      $uniqueLJPairCoeffs[$atomType] = "$ljPairCoeffs_ref->[$atom1Z][1] ".
         "$ljPairCoeffs_ref->[$atom1Z][2]";
      $uniqueMasses[$atomType] = $atomicMasses_ref->[$atom1Z];
   }

   # At this point the total number of unique atom types and bond types has
   #   been discovered. We also have all the coefficients for each unique atom
   #   and bond. Now we just go back through all of the molecule files and the
   #   lammps.dat file and adjust their contents.

   # Adjust the contents of the lammps.dat file.
   open (LMP,">lammps.dat") || die "Cannot open lammps.dat for writing.\n";

   $lineNum = 0;
   while ($lineNum <= $#lammpsFile)
   {
      $line = $lammpsFile[$lineNum++];
      if ($line =~ /atom types/)
         {print LMP "$numUniqueAtomTypes atom types\n";}
      elsif ($line =~ /atoms/)
      {
         @values = StructureControl::prepLine("",$line,'\s+');
         $numAtoms = $values[0];
         print LMP "$numAtoms atoms\n";
      }
      elsif ($line =~ /Masses/)
      {
         print LMP "Masses\n\n";
         foreach $uniqueAtom (1..$numUniqueAtomTypes)
         {
            print LMP "$uniqueAtom $uniqueMasses[$uniqueAtom] ".
               "# $uniqueAtomTypes[$uniqueAtom]\n";
         }
         $lineNum += $numAtomTypes+1; # Increment by original number of types.
      }
      elsif ($line =~ /Pair Coeffs/)
      {
         print LMP "Pair Coeffs\n\n";
         foreach $uniqueAtom (1..$numUniqueAtomTypes)
         {
            print LMP "$uniqueAtom $uniqueLJPairCoeffs[$uniqueAtom] ".
               "# $uniqueAtomTypes[$uniqueAtom]\n";
         }
         $lineNum += $numAtomTypes+1; # Increment by original number of types.
      }
      elsif ($line =~ /bond types/)
         {print LMP "$numUniqueBonds bond types\n";}
      elsif ($line =~ /bonds/)
      {
         @values = StructureControl::prepLine("",$line,'\s+');
         $numBonds = $values[0];
         print LMP "$numBonds bonds\n";
      }
      elsif ($line =~ /Bond Coeffs/)
      {
         print LMP "Bond Coeffs\n\n";
         foreach $uniqueBond (1..$numUniqueBonds)
         {
            print LMP "$uniqueBond $uniqueBondCoeffs[$uniqueBond][1] " .
               "$uniqueBondCoeffs[$uniqueBond][2] " .
               "# $uniqueBondTypes[$uniqueBond][1] " .
               "$uniqueBondTypes[$uniqueBond][2]\n";
         }
         $lineNum += $numBondTypes+1; # Increment by original num of types.
      }
      elsif ($line =~ /Bonds/)
      {
         print LMP "Bonds\n\n";
         foreach $bond (1..$numBonds)
         {
            @values = StructureControl::prepLine("",
               "$lammpsFile[++$lineNum]",'\s+');
            $bondType1 = "$values[5] $values[6] $values[7]";
            $bondType2 = "$values[8] $values[9] $values[10]";

            # Each bond line has a form like:
            #   14 2 21 33 # si 1 molName_1 n 2 molName_2 with meaning:
            #   Bond number = 14; bond type = 2; bond is between atoms 21 & 33.
            #   Atom 21 is silicon type 1 from a molecule with name molName_1
            #   and atom 33 is nitrogen type 2 from a molecule with name
            #   molName_2.
            # We need to make an alphabetized bondTag like:
            #   "n 2 molName_2 si 1 molName_1" because all of the uniqueBonds
            #   are alphabetized.
            if ("$bondType1" gt "$bondType2")
               {$bondTag = "$bondType2 $bondType1";}
            else
               {$bondTag = "$bondType1 $bondType2";}

            foreach $uniqueBond (1..$numUniqueBonds)
            {
               if ((($bondType1 eq $uniqueBondTypes[$uniqueBond][1]) and
                    ($bondType2 eq $uniqueBondTypes[$uniqueBond][2])) or
                   (($bondType1 eq $uniqueBondTypes[$uniqueBond][2]) and
                    ($bondType2 eq $uniqueBondTypes[$uniqueBond][1])))
                  {print LMP "$bond $uniqueBond $values[2] $values[3] " .
                     "$values[4] $bondTag\n"; last;}
            }
         }
         $lineNum++;
      }
      elsif ($line =~ /angle types/)
         {print LMP "$numUniqueAngles angle types\n";}
      elsif ($line =~ /angles/)
      {
         @values = StructureControl::prepLine("",$line,'\s+');
         $numAngles = $values[0];
         print LMP "$numAngles angles\n";
      }
      elsif ($line =~ /Angle Coeffs/)
      {
         print LMP "Angle Coeffs\n\n";
         foreach $uniqueAngle (1..$numUniqueAngles)
         {
#print STDOUT "uniqueAngle = $uniqueAngle\n";
#print STDOUT "uniqueAngleCoeffs[$uniqueAngle][1] = $uniqueAngleCoeffs[$uniqueAngle][1]\n";
#print STDOUT "uniqueAngleCoeffs[$uniqueAngle][2] = $uniqueAngleCoeffs[$uniqueAngle][2]\n";
            print LMP "$uniqueAngle $uniqueAngleCoeffs[$uniqueAngle][1] ".
               "$uniqueAngleCoeffs[$uniqueAngle][2] ".
               "# $uniqueAngleTypes[$uniqueAngle][1] ".
               "$uniqueAngleTypes[$uniqueAngle][2] ".
               "$uniqueAngleTypes[$uniqueAngle][3] ".
               "$uniqueAngleTypes[$uniqueAngle][4]\n";
         }
         $lineNum += $numAngleTypes+1; # Increment by original num of types.
      }
      elsif ($line =~ /Angles/)
      {
         print LMP "Angles\n\n";
         foreach $angle (1..$numAngles)
         {
            @values = StructureControl::prepLine("",
               "$lammpsFile[++$lineNum]",'\s+');
            $angleType1 = "$values[6] $values[7] $values[8]";
            $angleType2 = "$values[9] $values[10] $values[11]";
            $angleType3 = "$values[12] $values[13] $values[14]";
            $angleType4 = "$values[15] $values[16]";

            # Each angle line has a form like:
            #   14 2 10 9 13 # b 2 name1 c 1 name2 h 1 name3 angle type
            #   with meaning: Bond angle number = 14; bond type = 2, bond is
            #   between atom numbers 10, 9, 13 with 9 being at the vertex.
            #   Atom 10 is boron type 2 from molecule with name name1, atom
            #   9 is carbon type 1 from molecule with name name2 (currently
            #   must be the same as name1, atom 13 is hydrogen type 1 from
            #   molecule with name name3 (also the same as name1).
            #   Finally, the angle and the angle type is given.
            # We need to make an alphabetized (comparing first and last atoms)
            #   angle tag.
            if ($angleType1 gt $angleType3)
               {$angleTag = "$angleType3 $angleType2 $angleType1 $angleType4";}
            else
               {$angleTag = "$angleType1 $angleType2 $angleType3 $angleType4";}

            foreach $uniqueAngle (1..$numUniqueAngles)
            {
               if ((($angleType1 eq $uniqueAngleTypes[$uniqueAngle][1]) and
                    ($angleType2 eq $uniqueAngleTypes[$uniqueAngle][2]) and
                    ($angleType3 eq $uniqueAngleTypes[$uniqueAngle][3]) and
                    ($angleType4 eq $uniqueAngleTypes[$uniqueAngle][4])) or
                   (($angleType3 eq $uniqueAngleTypes[$uniqueAngle][1]) and
                    ($angleType2 eq $uniqueAngleTypes[$uniqueAngle][2]) and
                    ($angleType1 eq $uniqueAngleTypes[$uniqueAngle][3]) and
                    ($angleType4 eq $uniqueAngleTypes[$uniqueAngle][4])))
                  {print LMP "$angle $uniqueAngle $values[2] $values[3] ".
                     "$values[4] # $angleTag\n"; last;}
            }
         }
         $lineNum++;
      }
      else
         {print LMP "$line\n";}
   }
   close (LMP);


   # Adjust the contents of each of the molecule files.
   foreach $mol (1..$numMolFiles)
   {
      # Open the current molecule file.
      open (MOL,"<$molFiles[$mol]") ||
         die "Cannot open $molFiles[$mol] for reading";

      # Read the whole molecule data file into memory.
      @molFile = <MOL>;
      chomp(@molFile);
      close (MOL);

      # Parse the molecule file in memory and modify the one on disk at the
      #   same time.
      open (MOL,">$molFiles[$mol]") ||
         die "Cannot open $molFiles[$mol] for writing";
      $lineNum = 0;
      while ($lineNum <= $#molFile)
      {
         $line = $molFile[$lineNum];
         if ($line =~ /atoms/)
         {
            print MOL "$line\n";
            @values = StructureControl::prepLine("",$line,'\s+');
            $numAtoms = $values[0];
         }
         elsif ($line =~ /bonds/)
         {
            print MOL "$line\n";
            @values = StructureControl::prepLine("",$line,'\s+');
            $numBonds = $values[0];
         }
         elsif ($line =~ /angles/)
         {
            print MOL "$line\n";
            @values = StructureControl::prepLine("",$line,'\s+');
            $numAngles = $values[0];
         }
         elsif ($line =~ /Types/)
         {
            print MOL "$line\n\n";
            $lineNum++;
            foreach $atom (1..$numAtoms)
            {
               # Study each atom and update the type as needed.
               @values = StructureControl::prepLine("","$molFile[++$lineNum]",
                  '\s+');

               # Adjust the molecule name to the family name.
               $values[5] = $molecule2FamilyMap{$values[5]};

               # Make the atom type tag
               $atomType = "$values[3] $values[4] $values[5]";

               # Determine what type of atom this is from the unique list.
               foreach $uniqueAtom (1..$numUniqueAtomTypes)
               {
                  if ("$uniqueAtomTypes[$uniqueAtom]" eq "$atomType")
                     {print MOL "$atom $uniqueAtom # $atomType\n"; last;}
               }
            }
         }
         elsif ($line =~ /Bonds/)
         {
            print MOL "$line\n\n";
            $lineNum++;
            foreach $bond (1..$numBonds)
            {
               # Study each bond and update the bond type as needed.
               @values = StructureControl::prepLine("","$molFile[++$lineNum]",
                  '\s+');

               # Adjust the molecule names to the family names.
               $values[7] = $molecule2FamilyMap{$values[7]};
               $values[10] = $molecule2FamilyMap{$values[10]};

               # Make the bond type tag.
               $bondType1 = "$values[5] $values[6] $values[7]";
               $bondType2 = "$values[8] $values[9] $values[10]";

               # As before for the main LAMMPS data file, we will need to
               #   use alphabetized tags.
               if ("$bondType1" gt "$bondType2")
                  {$bondTag = "$bondType2 $bondType1";}
               else
                  {$bondTag = "$bondType1 $bondType2";}

               # Determine what type of bond this is from the unique list.
               foreach $uniqueBond (1..$numUniqueBonds)
               {
                  if ((("$uniqueBondTypes[$uniqueBond][1]" eq "$bondType1") and
                       ("$uniqueBondTypes[$uniqueBond][2]" eq "$bondType2")) or
                      (("$uniqueBondTypes[$uniqueBond][2]" eq "$bondType1") and
                       ("$uniqueBondTypes[$uniqueBond][1]" eq "$bondType2")))
                     {print MOL "$bond $uniqueBond $values[2] $values[3] " .
                        "$values[4] $bondTag\n"; last;}
               }
            }
         }
         elsif ($line =~ /Angles/)
         {
            print MOL "$line\n\n";
            $lineNum++;
            foreach $angle (1..$numAngles)
            {
               # Study each bond angle and update the type as needed.
               @values = StructureControl::prepLine("","$molFile[++$lineNum]",
                  '\s+');

               # Adjust the molecule names to the family names.
               $values[8] = $molecule2FamilyMap{$values[8]};
               $values[11] = $molecule2FamilyMap{$values[11]};
               $values[14] = $molecule2FamilyMap{$values[14]};

               # Make the angle type tag.
               $angleType1 = "$values[6] $values[7] $values[8]";
               $angleType2 = "$values[9] $values[10] $values[11]";
               $angleType3 = "$values[12] $values[13] $values[14]";
               $angleType4 = "$values[15] $values[16]";

               # As before for the main LAMMPS data file, we will need to use
               #   alphabetized tags.
               if ($angleType1 gt $angleType3)
                  {$angleTag = "$angleType3 $angleType2 $angleType1 ".
                     "$angleType4";}
               else
                  {$angleTag = "$angleType1 $angleType2 $angleType3 ".
                     "$angleType4";}
               foreach $uniqueAngle (1..$numUniqueAngles)
               {
                  if ((($angleType1 eq $uniqueAngleTypes[$uniqueAngle][1]) and
                       ($angleType2 eq $uniqueAngleTypes[$uniqueAngle][2]) and
                       ($angleType3 eq $uniqueAngleTypes[$uniqueAngle][3]) and
                       ($angleType4 eq $uniqueAngleTypes[$uniqueAngle][4])) or
                      (($angleType3 eq $uniqueAngleTypes[$uniqueAngle][1]) and
                       ($angleType2 eq $uniqueAngleTypes[$uniqueAngle][2]) and
                       ($angleType1 eq $uniqueAngleTypes[$uniqueAngle][3]) and
                       ($angleType4 eq $uniqueAngleTypes[$uniqueAngle][4])))
                     {print MOL "$angle $uniqueAngle $values[2] $values[3] ".
                        "$values[4] # $angleTag\n"; last;}
               }
            }
         }
         else
            {print MOL "$line\n";}
         $lineNum++;
      }
      close (MOL);
   }

   # Return to the project directory.
   chdir ("..");
}
